import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __export,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/react-scroll-snap-anime-slider/dist/index.module.js
var import_react = __toESM(require_react());

// node_modules/popmotion/node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p2 in b4) if (b4.hasOwnProperty(p2)) d3[p2] = b4[p2];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign5(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}

// node_modules/style-value-types/node_modules/tslib/tslib.es6.js
var __assign2 = function() {
  __assign2 = Object.assign || function __assign5(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};

// node_modules/style-value-types/dist/style-value-types.es.js
var clamp = function(min, max) {
  return function(v2) {
    return Math.max(Math.min(v2, max), min);
  };
};
var sanitize = function(v2) {
  return v2 % 1 ? Number(v2.toFixed(5)) : v2;
};
var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
var number = {
  test: function(v2) {
    return typeof v2 === "number";
  },
  parse: parseFloat,
  transform: function(v2) {
    return v2;
  }
};
var alpha = __assign2(__assign2({}, number), { transform: clamp(0, 1) });
var scale = __assign2(__assign2({}, number), { default: 1 });
var createUnitType = function(unit) {
  return {
    test: function(v2) {
      return typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1;
    },
    parse: parseFloat,
    transform: function(v2) {
      return "" + v2 + unit;
    }
  };
};
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = __assign2(__assign2({}, percent), { parse: function(v2) {
  return percent.parse(v2) / 100;
}, transform: function(v2) {
  return percent.transform(v2 * 100);
} });
var getValueFromFunctionString = function(value2) {
  return value2.substring(value2.indexOf("(") + 1, value2.lastIndexOf(")"));
};
var clampRgbUnit = clamp(0, 255);
var isRgba = function(v2) {
  return v2.red !== void 0;
};
var isHsla = function(v2) {
  return v2.hue !== void 0;
};
function getValuesAsArray(value2) {
  return getValueFromFunctionString(value2).replace(/(,|\/)/g, " ").split(/ \s*/);
}
var splitColorValues = function(terms) {
  return function(v2) {
    if (typeof v2 !== "string")
      return v2;
    var values = {};
    var valuesArray = getValuesAsArray(v2);
    for (var i = 0; i < 4; i++) {
      values[terms[i]] = valuesArray[i] !== void 0 ? parseFloat(valuesArray[i]) : 1;
    }
    return values;
  };
};
var rgbaTemplate = function(_a) {
  var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha2 = _b === void 0 ? 1 : _b;
  return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha2 + ")";
};
var hslaTemplate = function(_a) {
  var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha2 = _b === void 0 ? 1 : _b;
  return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha2 + ")";
};
var rgbUnit = __assign2(__assign2({}, number), { transform: function(v2) {
  return Math.round(clampRgbUnit(v2));
} });
function isColorString(color2, colorType) {
  return color2.startsWith(colorType) && singleColorRegex.test(color2);
}
var rgba = {
  test: function(v2) {
    return typeof v2 === "string" ? isColorString(v2, "rgb") : isRgba(v2);
  },
  parse: splitColorValues(["red", "green", "blue", "alpha"]),
  transform: function(_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return rgbaTemplate({
      red: rgbUnit.transform(red),
      green: rgbUnit.transform(green),
      blue: rgbUnit.transform(blue),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
var hsla = {
  test: function(v2) {
    return typeof v2 === "string" ? isColorString(v2, "hsl") : isHsla(v2);
  },
  parse: splitColorValues(["hue", "saturation", "lightness", "alpha"]),
  transform: function(_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return hslaTemplate({
      hue: Math.round(hue),
      saturation: percent.transform(sanitize(saturation)),
      lightness: percent.transform(sanitize(lightness)),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
var hex = __assign2(__assign2({}, rgba), { test: function(v2) {
  return typeof v2 === "string" && isColorString(v2, "#");
}, parse: function(v2) {
  var r = "";
  var g2 = "";
  var b3 = "";
  if (v2.length > 4) {
    r = v2.substr(1, 2);
    g2 = v2.substr(3, 2);
    b3 = v2.substr(5, 2);
  } else {
    r = v2.substr(1, 1);
    g2 = v2.substr(2, 1);
    b3 = v2.substr(3, 1);
    r += r;
    g2 += g2;
    b3 += b3;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b3, 16),
    alpha: 1
  };
} });
var color = {
  test: function(v2) {
    return typeof v2 === "string" && singleColorRegex.test(v2) || isRgba(v2) || isHsla(v2);
  },
  parse: function(v2) {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else if (hex.test(v2)) {
      return hex.parse(v2);
    }
    return v2;
  },
  transform: function(v2) {
    if (isRgba(v2)) {
      return rgba.transform(v2);
    } else if (isHsla(v2)) {
      return hsla.transform(v2);
    }
    return v2;
  }
};
var COLOR_TOKEN = "${c}";
var NUMBER_TOKEN = "${n}";
var convertNumbersToZero = function(v2) {
  return typeof v2 === "number" ? 0 : v2;
};
var complex = {
  test: function(v2) {
    if (typeof v2 !== "string" || !isNaN(v2))
      return false;
    var numValues = 0;
    var foundNumbers = v2.match(floatRegex);
    var foundColors = v2.match(colorRegex);
    if (foundNumbers)
      numValues += foundNumbers.length;
    if (foundColors)
      numValues += foundColors.length;
    return numValues > 0;
  },
  parse: function(v2) {
    var input = v2;
    var parsed = [];
    var foundColors = input.match(colorRegex);
    if (foundColors) {
      input = input.replace(colorRegex, COLOR_TOKEN);
      parsed.push.apply(parsed, foundColors.map(color.parse));
    }
    var foundNumbers = input.match(floatRegex);
    if (foundNumbers) {
      parsed.push.apply(parsed, foundNumbers.map(number.parse));
    }
    return parsed;
  },
  createTransformer: function(prop) {
    var template = prop;
    var token = 0;
    var foundColors = prop.match(colorRegex);
    var numColors = foundColors ? foundColors.length : 0;
    if (foundColors) {
      for (var i = 0; i < numColors; i++) {
        template = template.replace(foundColors[i], COLOR_TOKEN);
        token++;
      }
    }
    var foundNumbers = template.match(floatRegex);
    var numNumbers = foundNumbers ? foundNumbers.length : 0;
    if (foundNumbers) {
      for (var i = 0; i < numNumbers; i++) {
        template = template.replace(foundNumbers[i], NUMBER_TOKEN);
        token++;
      }
    }
    return function(v2) {
      var output = template;
      for (var i2 = 0; i2 < token; i2++) {
        output = output.replace(i2 < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i2 < numColors ? color.transform(v2[i2]) : sanitize(v2[i2]));
      }
      return output;
    };
  },
  getAnimatableNone: function(target) {
    var parsedTarget = complex.parse(target);
    var targetTransformer = complex.createTransformer(target);
    return targetTransformer(parsedTarget.map(convertNumbersToZero));
  }
};

// node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// node_modules/@popmotion/popcorn/node_modules/framesync/dist/framesync.es.js
var prevTime = 0;
var onNextFrame = typeof window !== "undefined" && window.requestAnimationFrame !== void 0 ? function(callback) {
  return window.requestAnimationFrame(callback);
} : function(callback) {
  var timestamp = Date.now();
  var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));
  prevTime = timestamp + timeToCall;
  setTimeout(function() {
    return callback(prevTime);
  }, timeToCall);
};
var createStep = function(setRunNextFrame) {
  var processToRun = [];
  var processToRunNextFrame = [];
  var numThisFrame = 0;
  var isProcessing4 = false;
  var i = 0;
  var cancelled = /* @__PURE__ */ new WeakSet();
  var toKeepAlive = /* @__PURE__ */ new WeakSet();
  var renderStep = {
    cancel: function(process2) {
      var indexOfCallback = processToRunNextFrame.indexOf(process2);
      cancelled.add(process2);
      if (indexOfCallback !== -1) {
        processToRunNextFrame.splice(indexOfCallback, 1);
      }
    },
    process: function(frame4) {
      var _a;
      isProcessing4 = true;
      _a = [processToRunNextFrame, processToRun], processToRun = _a[0], processToRunNextFrame = _a[1];
      processToRunNextFrame.length = 0;
      numThisFrame = processToRun.length;
      if (numThisFrame) {
        var process_1;
        for (i = 0; i < numThisFrame; i++) {
          process_1 = processToRun[i];
          process_1(frame4);
          if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
            renderStep.schedule(process_1);
            setRunNextFrame(true);
          }
        }
      }
      isProcessing4 = false;
    },
    schedule: function(process2, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      invariant(typeof process2 === "function", "Argument must be a function");
      var addToCurrentBuffer = immediate && isProcessing4;
      var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
      cancelled.delete(process2);
      if (keepAlive) toKeepAlive.add(process2);
      if (buffer.indexOf(process2) === -1) {
        buffer.push(process2);
        if (addToCurrentBuffer) numThisFrame = processToRun.length;
      }
    }
  };
  return renderStep;
};
var maxElapsed = 40;
var defaultElapsed = 1 / 60 * 1e3;
var useDefaultElapsed = true;
var willRunNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var setWillRunNextFrame = function(willRun) {
  return willRunNextFrame = willRun;
};
var steps = stepsOrder.reduce(function(acc, key) {
  acc[key] = createStep(setWillRunNextFrame);
  return acc;
}, {});
var sync = stepsOrder.reduce(function(acc, key) {
  var step = steps[key];
  acc[key] = function(process2, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!willRunNextFrame) startLoop();
    step.schedule(process2, keepAlive, immediate);
    return process2;
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce(function(acc, key) {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var processStep = function(stepId) {
  return steps[stepId].process(frame);
};
var processFrame = function(timestamp) {
  willRunNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultElapsed : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  if (!useDefaultElapsed) defaultElapsed = frame.delta;
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (willRunNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = function() {
  willRunNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing) onNextFrame(processFrame);
};
var getFrameData = function() {
  return frame;
};

// node_modules/@popmotion/easing/dist/easing.es.js
var easing_es_exports = {};
__export(easing_es_exports, {
  anticipate: () => anticipate,
  backIn: () => backIn,
  backInOut: () => backInOut,
  backOut: () => backOut,
  bounceIn: () => bounceIn,
  bounceInOut: () => bounceInOut,
  bounceOut: () => bounceOut,
  circIn: () => circIn,
  circInOut: () => circInOut,
  circOut: () => circOut,
  createAnticipateEasing: () => createAnticipateEasing,
  createBackIn: () => createBackIn,
  createExpoIn: () => createExpoIn,
  createMirroredEasing: () => createMirroredEasing,
  createReversedEasing: () => createReversedEasing,
  cubicBezier: () => cubicBezier,
  easeIn: () => easeIn,
  easeInOut: () => easeInOut,
  easeOut: () => easeOut,
  linear: () => linear,
  mirrored: () => mirrored,
  reversed: () => reversed
});
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var reversed = function(easing) {
  return function(p2) {
    return 1 - easing(1 - p2);
  };
};
var mirrored = function(easing) {
  return function(p2) {
    return p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
  };
};
var createReversedEasing = reversed;
var createMirroredEasing = mirrored;
var createExpoIn = function(power) {
  return function(p2) {
    return Math.pow(p2, power);
  };
};
var createBackIn = function(power) {
  return function(p2) {
    return p2 * p2 * ((power + 1) * p2 - power);
  };
};
var createAnticipateEasing = function(power) {
  var backEasing = createBackIn(power);
  return function(p2) {
    return (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
  };
};
var linear = function(p2) {
  return p2;
};
var easeIn = createExpoIn(2);
var easeOut = reversed(easeIn);
var easeInOut = mirrored(easeIn);
var circIn = function(p2) {
  return 1 - Math.sin(Math.acos(p2));
};
var circOut = reversed(circIn);
var circInOut = mirrored(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reversed(backIn);
var backInOut = mirrored(backIn);
var anticipate = createAnticipateEasing(DEFAULT_OVERSHOOT_STRENGTH);
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = function(p2) {
  var p22 = p2 * p2;
  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;
};
var bounceIn = function(p2) {
  return 1 - bounceOut(1 - p2);
};
var bounceInOut = function(p2) {
  return p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;
};
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 1e-3;
var SUBDIVISION_PRECISION = 1e-7;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1 / (K_SPLINE_TABLE_SIZE - 1);
var FLOAT_32_SUPPORTED = typeof Float32Array !== "undefined";
var a = function(a1, a2) {
  return 1 - 3 * a2 + 3 * a1;
};
var b = function(a1, a2) {
  return 3 * a2 - 6 * a1;
};
var c = function(a1) {
  return 3 * a1;
};
var getSlope = function(t2, a1, a2) {
  return 3 * a(a1, a2) * t2 * t2 + 2 * b(a1, a2) * t2 + c(a1);
};
var calcBezier = function(t2, a1, a2) {
  return ((a(a1, a2) * t2 + b(a1, a2)) * t2 + c(a1)) * t2;
};
function cubicBezier(mX1, mY1, mX2, mY2) {
  var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);
  var binarySubdivide = function(aX, aA, aB) {
    var i = 0;
    var currentX;
    var currentT;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  };
  var newtonRaphsonIterate = function(aX, aGuessT) {
    var i = 0;
    var currentSlope = 0;
    var currentX;
    for (; i < NEWTON_ITERATIONS; ++i) {
      currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0) {
        return aGuessT;
      }
      currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  var calcSampleValues = function() {
    for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
      sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
    }
  };
  var getTForX = function(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = K_SPLINE_TABLE_SIZE - 1;
    var dist = 0;
    var guessForT = 0;
    var initialSlope = 0;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += K_SAMPLE_STEP_SIZE;
    }
    --currentSample;
    dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;
    initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
    }
  };
  calcSampleValues();
  var resolver = function(aX) {
    var returnValue;
    if (mX1 === mY1 && mX2 === mY2) {
      returnValue = aX;
    } else if (aX === 0) {
      returnValue = 0;
    } else if (aX === 1) {
      returnValue = 1;
    } else {
      returnValue = calcBezier(getTForX(aX), mY1, mY2);
    }
    return returnValue;
  };
  return resolver;
}

// node_modules/@popmotion/popcorn/dist/popcorn.es.js
var zeroPoint = {
  x: 0,
  y: 0,
  z: 0
};
var isNum = function(v2) {
  return typeof v2 === "number";
};
var radiansToDegrees = function(radians) {
  return radians * 180 / Math.PI;
};
var angle = function(a2, b3) {
  if (b3 === void 0) {
    b3 = zeroPoint;
  }
  return radiansToDegrees(Math.atan2(b3.y - a2.y, b3.x - a2.x));
};
var applyOffset = function(from, to) {
  var hasReceivedFrom = true;
  if (to === void 0) {
    to = from;
    hasReceivedFrom = false;
  }
  return function(v2) {
    if (hasReceivedFrom) {
      return v2 - from + to;
    } else {
      from = v2;
      hasReceivedFrom = true;
      return to;
    }
  };
};
var curryRange = function(func) {
  return function(min, max, v2) {
    return v2 !== void 0 ? func(min, max, v2) : function(cv) {
      return func(min, max, cv);
    };
  };
};
var clamp2 = function(min, max, v2) {
  return Math.min(Math.max(v2, min), max);
};
var clamp$1 = curryRange(clamp2);
var conditional = function(check, apply) {
  return function(v2) {
    return check(v2) ? apply(v2) : v2;
  };
};
var degreesToRadians = function(degrees2) {
  return degrees2 * Math.PI / 180;
};
var isPoint = function(point2) {
  return point2.hasOwnProperty("x") && point2.hasOwnProperty("y");
};
var isPoint3D = function(point2) {
  return isPoint(point2) && point2.hasOwnProperty("z");
};
var distance1D = function(a2, b3) {
  return Math.abs(a2 - b3);
};
var distance = function(a2, b3) {
  if (b3 === void 0) {
    b3 = zeroPoint;
  }
  if (isNum(a2) && isNum(b3)) {
    return distance1D(a2, b3);
  } else if (isPoint(a2) && isPoint(b3)) {
    var xDelta = distance1D(a2.x, b3.x);
    var yDelta = distance1D(a2.y, b3.y);
    var zDelta = isPoint3D(a2) && isPoint3D(b3) ? distance1D(a2.z, b3.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
  return 0;
};
var progress = function(from, to, value2) {
  var toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value2 - from) / toFromDifference;
};
var mix = function(from, to, progress2) {
  return -progress2 * from + progress2 * to + from;
};
var __assign3 = function() {
  __assign3 = Object.assign || function __assign5(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign3.apply(this, arguments);
};
var mixLinearColor = function(from, to, v2) {
  var fromExpo = from * from;
  var toExpo = to * to;
  return Math.sqrt(Math.max(0, v2 * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = function(v2) {
  return colorTypes.find(function(type) {
    return type.test(v2);
  });
};
var notAnimatable = function(color$$1) {
  return "'" + color$$1 + "' is not an animatable color. Use the equivalent color code instead.";
};
var mixColor = function(from, to) {
  var fromColorType = getColorType(from);
  var toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from));
  invariant(!!toColorType, notAnimatable(to));
  invariant(fromColorType.transform === toColorType.transform, "Both colors must be hex/RGBA, OR both must be HSLA.");
  var fromColor = fromColorType.parse(from);
  var toColor = toColorType.parse(to);
  var blended = __assign3({}, fromColor);
  var mixFunc = fromColorType === hsla ? mix : mixLinearColor;
  return function(v2) {
    for (var key in blended) {
      if (key !== "alpha") {
        blended[key] = mixFunc(fromColor[key], toColor[key], v2);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v2);
    return fromColorType.transform(blended);
  };
};
var combineFunctions = function(a2, b3) {
  return function(v2) {
    return b3(a2(v2));
  };
};
var pipe = function() {
  var transformers2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    transformers2[_i] = arguments[_i];
  }
  return transformers2.reduce(combineFunctions);
};
function getMixer(origin, target) {
  if (isNum(origin)) {
    return function(v2) {
      return mix(origin, target, v2);
    };
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
var mixArray = function(from, to) {
  var output = from.slice();
  var numValues = output.length;
  var blendValue = from.map(function(fromThis, i) {
    return getMixer(fromThis, to[i]);
  });
  return function(v2) {
    for (var i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v2);
    }
    return output;
  };
};
var mixObject = function(origin, target) {
  var output = __assign3({}, origin, target);
  var blendValue = {};
  for (var key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return function(v2) {
    for (var key2 in blendValue) {
      output[key2] = blendValue[key2](v2);
    }
    return output;
  };
};
function analyse(value2) {
  var parsed = complex.parse(value2);
  var numValues = parsed.length;
  var numNumbers = 0;
  var numRGB = 0;
  var numHSL = 0;
  for (var i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = function(origin, target) {
  var template = complex.createTransformer(target);
  var originStats = analyse(origin);
  var targetStats = analyse(target);
  invariant(originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers, "Complex values '" + origin + "' and '" + target + "' too different to mix. Ensure all colors are of the same type.");
  return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
};
var mixNumber = function(from, to) {
  return function(p2) {
    return mix(from, to, p2);
  };
};
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  var mixers = [];
  var mixerFactory = customMixer || detectMixerFactory(output[0]);
  var numMixers = output.length - 1;
  for (var i = 0; i < numMixers; i++) {
    var mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      var easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate(_a, _b) {
  var from = _a[0], to = _a[1];
  var mixer = _b[0];
  return function(v2) {
    return mixer(progress(from, to, v2));
  };
}
function slowInterpolate(input, mixers) {
  var inputLength = input.length;
  var lastInputIndex = inputLength - 1;
  return function(v2) {
    var mixerIndex = 0;
    var foundMixerIndex = false;
    if (v2 <= input[0]) {
      foundMixerIndex = true;
    } else if (v2 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      var i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v2 || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v2);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, _a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.clamp, clamp3 = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;
  var inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  var mixers = createMixers(output, ease, mixer);
  var interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return clamp3 ? pipe(clamp$1(input[0], input[inputLength - 1]), interpolator) : interpolator;
}
var pointFromVector = function(origin, angle2, distance2) {
  angle2 = degreesToRadians(angle2);
  return {
    x: distance2 * Math.cos(angle2) + origin.x,
    y: distance2 * Math.sin(angle2) + origin.y
  };
};
var toDecimal = function(num, precision) {
  if (precision === void 0) {
    precision = 2;
  }
  precision = Math.pow(10, precision);
  return Math.round(num * precision) / precision;
};
var smoothFrame = function(prevValue, nextValue, duration, smoothing) {
  if (smoothing === void 0) {
    smoothing = 0;
  }
  return toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));
};
var smooth = function(strength) {
  if (strength === void 0) {
    strength = 50;
  }
  var previousValue = 0;
  var lastUpdated = 0;
  return function(v2) {
    var currentFramestamp = getFrameData().timestamp;
    var timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;
    var newValue = timeDelta ? smoothFrame(previousValue, v2, timeDelta, strength) : previousValue;
    lastUpdated = currentFramestamp;
    previousValue = newValue;
    return newValue;
  };
};
var snap = function(points2) {
  if (typeof points2 === "number") {
    return function(v2) {
      return Math.round(v2 / points2) * points2;
    };
  } else {
    var i_1 = 0;
    var numPoints_1 = points2.length;
    return function(v2) {
      var lastDistance = Math.abs(points2[0] - v2);
      for (i_1 = 1; i_1 < numPoints_1; i_1++) {
        var point2 = points2[i_1];
        var distance2 = Math.abs(point2 - v2);
        if (distance2 === 0)
          return point2;
        if (distance2 > lastDistance)
          return points2[i_1 - 1];
        if (i_1 === numPoints_1 - 1)
          return point2;
        lastDistance = distance2;
      }
    };
  }
};
var identity = function(v2) {
  return v2;
};
var springForce = function(alterDisplacement) {
  if (alterDisplacement === void 0) {
    alterDisplacement = identity;
  }
  return curryRange(function(constant, origin, v2) {
    var displacement = origin - v2;
    var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
    return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
  });
};
var springForceLinear = springForce();
var springForceExpo = springForce(Math.sqrt);
var velocityPerFrame = function(xps, frameDuration) {
  return isNum(xps) ? xps / (1e3 / frameDuration) : 0;
};
var velocityPerSecond = function(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
};
var wrap = function(min, max, v2) {
  var rangeSize = max - min;
  return ((v2 - min) % rangeSize + rangeSize) % rangeSize + min;
};
var wrap$1 = curryRange(wrap);
var clampProgress = clamp$1(0, 1);

// node_modules/popmotion/node_modules/framesync/dist/framesync.es.js
var prevTime2 = 0;
var onNextFrame2 = typeof window !== "undefined" && window.requestAnimationFrame !== void 0 ? function(callback) {
  return window.requestAnimationFrame(callback);
} : function(callback) {
  var timestamp = Date.now();
  var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime2));
  prevTime2 = timestamp + timeToCall;
  setTimeout(function() {
    return callback(prevTime2);
  }, timeToCall);
};
var createStep2 = function(setRunNextFrame) {
  var processToRun = [];
  var processToRunNextFrame = [];
  var numThisFrame = 0;
  var isProcessing4 = false;
  var i = 0;
  var cancelled = /* @__PURE__ */ new WeakSet();
  var toKeepAlive = /* @__PURE__ */ new WeakSet();
  var renderStep = {
    cancel: function(process2) {
      var indexOfCallback = processToRunNextFrame.indexOf(process2);
      cancelled.add(process2);
      if (indexOfCallback !== -1) {
        processToRunNextFrame.splice(indexOfCallback, 1);
      }
    },
    process: function(frame4) {
      var _a;
      isProcessing4 = true;
      _a = [processToRunNextFrame, processToRun], processToRun = _a[0], processToRunNextFrame = _a[1];
      processToRunNextFrame.length = 0;
      numThisFrame = processToRun.length;
      if (numThisFrame) {
        var process_1;
        for (i = 0; i < numThisFrame; i++) {
          process_1 = processToRun[i];
          process_1(frame4);
          if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
            renderStep.schedule(process_1);
            setRunNextFrame(true);
          }
        }
      }
      isProcessing4 = false;
    },
    schedule: function(process2, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      invariant(typeof process2 === "function", "Argument must be a function");
      var addToCurrentBuffer = immediate && isProcessing4;
      var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
      cancelled.delete(process2);
      if (keepAlive) toKeepAlive.add(process2);
      if (buffer.indexOf(process2) === -1) {
        buffer.push(process2);
        if (addToCurrentBuffer) numThisFrame = processToRun.length;
      }
    }
  };
  return renderStep;
};
var maxElapsed2 = 40;
var defaultElapsed2 = 1 / 60 * 1e3;
var useDefaultElapsed2 = true;
var willRunNextFrame2 = false;
var isProcessing2 = false;
var frame2 = {
  delta: 0,
  timestamp: 0
};
var stepsOrder2 = ["read", "update", "preRender", "render", "postRender"];
var setWillRunNextFrame2 = function(willRun) {
  return willRunNextFrame2 = willRun;
};
var steps2 = stepsOrder2.reduce(function(acc, key) {
  acc[key] = createStep2(setWillRunNextFrame2);
  return acc;
}, {});
var sync2 = stepsOrder2.reduce(function(acc, key) {
  var step = steps2[key];
  acc[key] = function(process2, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!willRunNextFrame2) startLoop2();
    step.schedule(process2, keepAlive, immediate);
    return process2;
  };
  return acc;
}, {});
var cancelSync2 = stepsOrder2.reduce(function(acc, key) {
  acc[key] = steps2[key].cancel;
  return acc;
}, {});
var processStep2 = function(stepId) {
  return steps2[stepId].process(frame2);
};
var processFrame2 = function(timestamp) {
  willRunNextFrame2 = false;
  frame2.delta = useDefaultElapsed2 ? defaultElapsed2 : Math.max(Math.min(timestamp - frame2.timestamp, maxElapsed2), 1);
  if (!useDefaultElapsed2) defaultElapsed2 = frame2.delta;
  frame2.timestamp = timestamp;
  isProcessing2 = true;
  stepsOrder2.forEach(processStep2);
  isProcessing2 = false;
  if (willRunNextFrame2) {
    useDefaultElapsed2 = false;
    onNextFrame2(processFrame2);
  }
};
var startLoop2 = function() {
  willRunNextFrame2 = true;
  useDefaultElapsed2 = true;
  if (!isProcessing2) onNextFrame2(processFrame2);
};
var getFrameData2 = function() {
  return frame2;
};
var framesync_es_default = sync2;

// node_modules/stylefire/node_modules/tslib/tslib.es6.js
var __assign4 = function() {
  __assign4 = Object.assign || function __assign5(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign4.apply(this, arguments);
};
function __rest2(s, e2) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}

// node_modules/stylefire/node_modules/framesync/dist/framesync.es.js
var prevTime3 = 0;
var onNextFrame3 = typeof window !== "undefined" && window.requestAnimationFrame !== void 0 ? function(callback) {
  return window.requestAnimationFrame(callback);
} : function(callback) {
  var timestamp = Date.now();
  var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime3));
  prevTime3 = timestamp + timeToCall;
  setTimeout(function() {
    return callback(prevTime3);
  }, timeToCall);
};
var createStep3 = function(setRunNextFrame) {
  var processToRun = [];
  var processToRunNextFrame = [];
  var numThisFrame = 0;
  var isProcessing4 = false;
  var i = 0;
  var cancelled = /* @__PURE__ */ new WeakSet();
  var toKeepAlive = /* @__PURE__ */ new WeakSet();
  var renderStep = {
    cancel: function(process2) {
      var indexOfCallback = processToRunNextFrame.indexOf(process2);
      cancelled.add(process2);
      if (indexOfCallback !== -1) {
        processToRunNextFrame.splice(indexOfCallback, 1);
      }
    },
    process: function(frame4) {
      var _a;
      isProcessing4 = true;
      _a = [processToRunNextFrame, processToRun], processToRun = _a[0], processToRunNextFrame = _a[1];
      processToRunNextFrame.length = 0;
      numThisFrame = processToRun.length;
      if (numThisFrame) {
        var process_1;
        for (i = 0; i < numThisFrame; i++) {
          process_1 = processToRun[i];
          process_1(frame4);
          if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
            renderStep.schedule(process_1);
            setRunNextFrame(true);
          }
        }
      }
      isProcessing4 = false;
    },
    schedule: function(process2, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      invariant(typeof process2 === "function", "Argument must be a function");
      var addToCurrentBuffer = immediate && isProcessing4;
      var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
      cancelled.delete(process2);
      if (keepAlive) toKeepAlive.add(process2);
      if (buffer.indexOf(process2) === -1) {
        buffer.push(process2);
        if (addToCurrentBuffer) numThisFrame = processToRun.length;
      }
    }
  };
  return renderStep;
};
var maxElapsed3 = 40;
var defaultElapsed3 = 1 / 60 * 1e3;
var useDefaultElapsed3 = true;
var willRunNextFrame3 = false;
var isProcessing3 = false;
var frame3 = {
  delta: 0,
  timestamp: 0
};
var stepsOrder3 = ["read", "update", "preRender", "render", "postRender"];
var setWillRunNextFrame3 = function(willRun) {
  return willRunNextFrame3 = willRun;
};
var steps3 = stepsOrder3.reduce(function(acc, key) {
  acc[key] = createStep3(setWillRunNextFrame3);
  return acc;
}, {});
var sync3 = stepsOrder3.reduce(function(acc, key) {
  var step = steps3[key];
  acc[key] = function(process2, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!willRunNextFrame3) startLoop3();
    step.schedule(process2, keepAlive, immediate);
    return process2;
  };
  return acc;
}, {});
var cancelSync3 = stepsOrder3.reduce(function(acc, key) {
  acc[key] = steps3[key].cancel;
  return acc;
}, {});
var processStep3 = function(stepId) {
  return steps3[stepId].process(frame3);
};
var processFrame3 = function(timestamp) {
  willRunNextFrame3 = false;
  frame3.delta = useDefaultElapsed3 ? defaultElapsed3 : Math.max(Math.min(timestamp - frame3.timestamp, maxElapsed3), 1);
  if (!useDefaultElapsed3) defaultElapsed3 = frame3.delta;
  frame3.timestamp = timestamp;
  isProcessing3 = true;
  stepsOrder3.forEach(processStep3);
  isProcessing3 = false;
  if (willRunNextFrame3) {
    useDefaultElapsed3 = false;
    onNextFrame3(processFrame3);
  }
};
var startLoop3 = function() {
  willRunNextFrame3 = true;
  useDefaultElapsed3 = true;
  if (!isProcessing3) onNextFrame3(processFrame3);
};
var framesync_es_default2 = sync3;

// node_modules/stylefire/dist/stylefire.es.js
var createStyler = function(_a) {
  var onRead2 = _a.onRead, onRender2 = _a.onRender, _b = _a.uncachedValues, uncachedValues = _b === void 0 ? /* @__PURE__ */ new Set() : _b, _c = _a.useCache, useCache = _c === void 0 ? true : _c;
  return function(_a2) {
    if (_a2 === void 0) {
      _a2 = {};
    }
    var props = __rest2(_a2, []);
    var state = {};
    var changedValues = [];
    var hasChanged = false;
    function setValue(key, value2) {
      if (key.startsWith("--")) {
        props.hasCSSVariable = true;
      }
      var currentValue = state[key];
      state[key] = value2;
      if (state[key] === currentValue) return;
      if (changedValues.indexOf(key) === -1) {
        changedValues.push(key);
      }
      if (!hasChanged) {
        hasChanged = true;
        framesync_es_default2.render(styler.render);
      }
    }
    var styler = {
      get: function(key, forceRead) {
        if (forceRead === void 0) {
          forceRead = false;
        }
        var useCached = !forceRead && useCache && !uncachedValues.has(key) && state[key] !== void 0;
        return useCached ? state[key] : onRead2(key, props);
      },
      set: function(values, value2) {
        if (typeof values === "string") {
          setValue(values, value2);
        } else {
          for (var key in values) {
            setValue(key, values[key]);
          }
        }
        return this;
      },
      render: function(forceRender) {
        if (forceRender === void 0) {
          forceRender = false;
        }
        if (hasChanged || forceRender === true) {
          onRender2(state, props, changedValues);
          hasChanged = false;
          changedValues.length = 0;
        }
        return this;
      }
    };
    return styler;
  };
};
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};
var camelCache = /* @__PURE__ */ new Map();
var dashCache = /* @__PURE__ */ new Map();
var prefixes = ["Webkit", "Moz", "O", "ms", ""];
var numPrefixes = prefixes.length;
var isBrowser = typeof document !== "undefined";
var testElement;
var setDashPrefix = function(key, prefixed) {
  return dashCache.set(key, camelToDash(prefixed));
};
var testPrefix = function(key) {
  testElement = testElement || document.createElement("div");
  for (var i = 0; i < numPrefixes; i++) {
    var prefix = prefixes[i];
    var noPrefix = prefix === "";
    var prefixedPropertyName = noPrefix ? key : prefix + key.charAt(0).toUpperCase() + key.slice(1);
    if (prefixedPropertyName in testElement.style || noPrefix) {
      if (noPrefix && key === "clipPath" && dashCache.has(key)) {
        return;
      }
      camelCache.set(key, prefixedPropertyName);
      setDashPrefix(key, (noPrefix ? "" : "-") + camelToDash(prefixedPropertyName));
    }
  }
};
var setServerProperty = function(key) {
  return setDashPrefix(key, key);
};
var prefixer = function(key, asDashCase) {
  if (asDashCase === void 0) {
    asDashCase = false;
  }
  var cache = asDashCase ? dashCache : camelCache;
  if (!cache.has(key)) {
    isBrowser ? testPrefix(key) : setServerProperty(key);
  }
  return cache.get(key) || key;
};
var axes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew", "transformPerspective"];
var transformProps = order.reduce(function(acc, key) {
  return axes.reduce(function(axesAcc, axesKey) {
    axesAcc.push(key + axesKey);
    return axesAcc;
  }, acc);
}, ["x", "y", "z"]);
var transformPropDictionary = transformProps.reduce(function(dict, key) {
  dict[key] = true;
  return dict;
}, {});
function isTransformProp(key) {
  return transformPropDictionary[key] === true;
}
var int = __assign4(__assign4({}, number), { transform: Math.round });
var valueTypes = {
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
var getValueType = function(key) {
  return valueTypes[key];
};
var SCROLL_LEFT = "scrollLeft";
var SCROLL_TOP = "scrollTop";
var scrollKeys = /* @__PURE__ */ new Set([SCROLL_LEFT, SCROLL_TOP]);
function onRead(key, options) {
  var element = options.element, preparseOutput = options.preparseOutput;
  var defaultValueType = getValueType(key);
  if (isTransformProp(key)) {
    return defaultValueType ? defaultValueType.default || 0 : 0;
  } else if (scrollKeys.has(key)) {
    return element[key];
  } else {
    var domValue = window.getComputedStyle(element, null).getPropertyValue(prefixer(key, true)) || 0;
    return preparseOutput && defaultValueType && defaultValueType.test(domValue) && defaultValueType.parse ? defaultValueType.parse(domValue) : domValue;
  }
}
function onRender(state, _a, changedValues) {
  var element = _a.element, buildStyles = _a.buildStyles, hasCSSVariable = _a.hasCSSVariable;
  Object.assign(element.style, buildStyles(state));
  if (hasCSSVariable) {
    var numChangedValues = changedValues.length;
    for (var i = 0; i < numChangedValues; i++) {
      var key = changedValues[i];
      if (key.startsWith("--")) {
        element.style.setProperty(key, state[key]);
      }
    }
  }
  if (changedValues.indexOf(SCROLL_LEFT) !== -1) {
    element[SCROLL_LEFT] = state[SCROLL_LEFT];
  }
  if (changedValues.indexOf(SCROLL_TOP) !== -1) {
    element[SCROLL_TOP] = state[SCROLL_TOP];
  }
}
var cssStyler = createStyler({
  onRead,
  onRender,
  uncachedValues: scrollKeys
});
var camelCaseAttributes = /* @__PURE__ */ new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues"]);
var svgStyler = createStyler({
  onRead: function(key, _a) {
    var element = _a.element;
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    if (!isTransformProp(key)) {
      return element.getAttribute(key);
    } else {
      var valueType = getValueType(key);
      return valueType ? valueType.default || 0 : 0;
    }
  },
  onRender: function(state, _a) {
    var element = _a.element, buildAttrs = _a.buildAttrs;
    var attrs = buildAttrs(state);
    for (var key in attrs) {
      if (key === "style") {
        Object.assign(element.style, attrs.style);
      } else {
        element.setAttribute(key, attrs[key]);
      }
    }
  }
});
var viewport = createStyler({
  useCache: false,
  onRead: function(key) {
    return key === "scrollTop" ? window.pageYOffset : window.pageXOffset;
  },
  onRender: function(_a) {
    var _b = _a.scrollTop, scrollTop = _b === void 0 ? 0 : _b, _c = _a.scrollLeft, scrollLeft = _c === void 0 ? 0 : _c;
    return window.scrollTo(scrollLeft, scrollTop);
  }
});

// node_modules/popmotion/dist/popmotion.es.js
var Chainable = function() {
  function Chainable2(props) {
    if (props === void 0) {
      props = {};
    }
    this.props = props;
  }
  Chainable2.prototype.applyMiddleware = function(middleware) {
    return this.create(__assign({}, this.props, { middleware: this.props.middleware ? [middleware].concat(this.props.middleware) : [middleware] }));
  };
  Chainable2.prototype.pipe = function() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      funcs[_i] = arguments[_i];
    }
    var pipedUpdate = funcs.length === 1 ? funcs[0] : pipe.apply(void 0, funcs);
    return this.applyMiddleware(function(update) {
      return function(v2) {
        return update(pipedUpdate(v2));
      };
    });
  };
  Chainable2.prototype.while = function(predicate) {
    return this.applyMiddleware(function(update, complete) {
      return function(v2) {
        return predicate(v2) ? update(v2) : complete();
      };
    });
  };
  Chainable2.prototype.filter = function(predicate) {
    return this.applyMiddleware(function(update) {
      return function(v2) {
        return predicate(v2) && update(v2);
      };
    });
  };
  return Chainable2;
}();
var Observer = /* @__PURE__ */ function() {
  function Observer2(_a, observer) {
    var middleware = _a.middleware, onComplete = _a.onComplete;
    var _this = this;
    this.isActive = true;
    this.update = function(v2) {
      if (_this.observer.update) _this.updateObserver(v2);
    };
    this.complete = function() {
      if (_this.observer.complete && _this.isActive) _this.observer.complete();
      if (_this.onComplete) _this.onComplete();
      _this.isActive = false;
    };
    this.error = function(err) {
      if (_this.observer.error && _this.isActive) _this.observer.error(err);
      _this.isActive = false;
    };
    this.observer = observer;
    this.updateObserver = function(v2) {
      return observer.update(v2);
    };
    this.onComplete = onComplete;
    if (observer.update && middleware && middleware.length) {
      middleware.forEach(function(m2) {
        return _this.updateObserver = m2(_this.updateObserver, _this.complete);
      });
    }
  }
  return Observer2;
}();
var createObserver = function(observerCandidate, _a, onComplete) {
  var middleware = _a.middleware;
  if (typeof observerCandidate === "function") {
    return new Observer({ middleware, onComplete }, { update: observerCandidate });
  } else {
    return new Observer({ middleware, onComplete }, observerCandidate);
  }
};
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Action2.prototype.create = function(props) {
    return new Action2(props);
  };
  Action2.prototype.start = function(observerCandidate) {
    if (observerCandidate === void 0) {
      observerCandidate = {};
    }
    var isComplete = false;
    var subscription = {
      stop: function() {
        return void 0;
      }
    };
    var _a = this.props, init = _a.init, observerProps = __rest(_a, ["init"]);
    var observer = createObserver(observerCandidate, observerProps, function() {
      isComplete = true;
      subscription.stop();
    });
    var api = init(observer);
    subscription = api ? __assign({}, subscription, api) : subscription;
    if (observerCandidate.registerParent) {
      observerCandidate.registerParent(subscription);
    }
    if (isComplete) subscription.stop();
    return subscription;
  };
  return Action2;
}(Chainable);
var action = function(init) {
  return new Action({ init });
};
var BaseMulticast = function(_super) {
  __extends(BaseMulticast2, _super);
  function BaseMulticast2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.subscribers = [];
    return _this;
  }
  BaseMulticast2.prototype.complete = function() {
    this.subscribers.forEach(function(subscriber) {
      return subscriber.complete();
    });
  };
  BaseMulticast2.prototype.error = function(err) {
    this.subscribers.forEach(function(subscriber) {
      return subscriber.error(err);
    });
  };
  BaseMulticast2.prototype.update = function(v2) {
    for (var i = 0; i < this.subscribers.length; i++) {
      this.subscribers[i].update(v2);
    }
  };
  BaseMulticast2.prototype.subscribe = function(observerCandidate) {
    var _this = this;
    var observer = createObserver(observerCandidate, this.props);
    this.subscribers.push(observer);
    var subscription = {
      unsubscribe: function() {
        var index2 = _this.subscribers.indexOf(observer);
        if (index2 !== -1) _this.subscribers.splice(index2, 1);
      }
    };
    return subscription;
  };
  BaseMulticast2.prototype.stop = function() {
    if (this.parent) this.parent.stop();
  };
  BaseMulticast2.prototype.registerParent = function(subscription) {
    this.stop();
    this.parent = subscription;
  };
  return BaseMulticast2;
}(Chainable);
var Multicast = function(_super) {
  __extends(Multicast2, _super);
  function Multicast2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Multicast2.prototype.create = function(props) {
    return new Multicast2(props);
  };
  return Multicast2;
}(BaseMulticast);
var stepProgress = function(steps5, progress$$1) {
  var segment = 1 / (steps5 - 1);
  var subsegment = 1 / (2 * (steps5 - 1));
  var percentProgressOfTarget = Math.min(progress$$1, 1);
  var subsegmentProgressOfTarget = percentProgressOfTarget / subsegment;
  var segmentProgressOfTarget = Math.floor((subsegmentProgressOfTarget + 1) / 2);
  return segmentProgressOfTarget * segment;
};
var calc = Object.freeze({
  angle,
  degreesToRadians,
  distance,
  isPoint3D,
  isPoint,
  dilate: mix,
  getValueFromProgress: mix,
  pointFromAngleAndDistance: pointFromVector,
  getProgressFromValue: progress,
  radiansToDegrees,
  smooth: smoothFrame,
  speedPerFrame: velocityPerFrame,
  speedPerSecond: velocityPerSecond,
  stepProgress
});
var isValueList = function(v2) {
  return Array.isArray(v2);
};
var isSingleValue = function(v2) {
  var typeOfV = typeof v2;
  return typeOfV === "string" || typeOfV === "number";
};
var ValueReaction = function(_super) {
  __extends(ValueReaction2, _super);
  function ValueReaction2(props) {
    var _this = _super.call(this, props) || this;
    _this.scheduleVelocityCheck = function() {
      return framesync_es_default.postRender(_this.velocityCheck);
    };
    _this.velocityCheck = function(_a) {
      var timestamp = _a.timestamp;
      if (timestamp !== _this.lastUpdated) {
        _this.prev = _this.current;
      }
    };
    _this.prev = _this.current = props.value || 0;
    if (isSingleValue(_this.current)) {
      _this.updateCurrent = function(v2) {
        return _this.current = v2;
      };
      _this.getVelocityOfCurrent = function() {
        return _this.getSingleVelocity(_this.current, _this.prev);
      };
    } else if (isValueList(_this.current)) {
      _this.updateCurrent = function(v2) {
        return _this.current = v2.slice();
      };
      _this.getVelocityOfCurrent = function() {
        return _this.getListVelocity();
      };
    } else {
      _this.updateCurrent = function(v2) {
        _this.current = {};
        for (var key in v2) {
          if (v2.hasOwnProperty(key)) {
            _this.current[key] = v2[key];
          }
        }
      };
      _this.getVelocityOfCurrent = function() {
        return _this.getMapVelocity();
      };
    }
    if (props.initialSubscription) _this.subscribe(props.initialSubscription);
    return _this;
  }
  ValueReaction2.prototype.create = function(props) {
    return new ValueReaction2(props);
  };
  ValueReaction2.prototype.get = function() {
    return this.current;
  };
  ValueReaction2.prototype.getVelocity = function() {
    return this.getVelocityOfCurrent();
  };
  ValueReaction2.prototype.update = function(v2) {
    _super.prototype.update.call(this, v2);
    this.prev = this.current;
    this.updateCurrent(v2);
    var _a = getFrameData2(), delta = _a.delta, timestamp = _a.timestamp;
    this.timeDelta = delta;
    this.lastUpdated = timestamp;
    framesync_es_default.postRender(this.scheduleVelocityCheck);
  };
  ValueReaction2.prototype.subscribe = function(observerCandidate) {
    var sub = _super.prototype.subscribe.call(this, observerCandidate);
    this.subscribers[this.subscribers.length - 1].update(this.current);
    return sub;
  };
  ValueReaction2.prototype.getSingleVelocity = function(current, prev) {
    return typeof current === "number" && typeof prev === "number" ? velocityPerSecond(current - prev, this.timeDelta) : velocityPerSecond(parseFloat(current) - parseFloat(prev), this.timeDelta) || 0;
  };
  ValueReaction2.prototype.getListVelocity = function() {
    var _this = this;
    return this.current.map(function(c3, i) {
      return _this.getSingleVelocity(c3, _this.prev[i]);
    });
  };
  ValueReaction2.prototype.getMapVelocity = function() {
    var velocity = {};
    for (var key in this.current) {
      if (this.current.hasOwnProperty(key)) {
        velocity[key] = this.getSingleVelocity(this.current[key], this.prev[key]);
      }
    }
    return velocity;
  };
  return ValueReaction2;
}(BaseMulticast);
var value = function(value2, initialSubscription) {
  return new ValueReaction({ value: value2, initialSubscription });
};
var multi = function(_a) {
  var getCount = _a.getCount, getFirst = _a.getFirst, getOutput = _a.getOutput, mapApi = _a.mapApi, setProp = _a.setProp, startActions = _a.startActions;
  return function(actions) {
    return action(function(_a2) {
      var update = _a2.update, complete = _a2.complete, error = _a2.error;
      var numActions = getCount(actions);
      var output = getOutput();
      var updateOutput = function() {
        return update(output);
      };
      var numCompletedActions = 0;
      var subs = startActions(actions, function(a2, name) {
        var hasCompleted = false;
        return a2.start({
          complete: function() {
            if (!hasCompleted) {
              hasCompleted = true;
              numCompletedActions++;
              if (numCompletedActions === numActions) framesync_es_default.update(complete);
            }
          },
          error,
          update: function(v2) {
            setProp(output, name, v2);
            framesync_es_default.update(updateOutput, false, true);
          }
        });
      });
      return Object.keys(getFirst(subs)).reduce(function(api, methodName) {
        api[methodName] = mapApi(subs, methodName);
        return api;
      }, {});
    });
  };
};
var composite = multi({
  getOutput: function() {
    return {};
  },
  getCount: function(subs) {
    return Object.keys(subs).length;
  },
  getFirst: function(subs) {
    return subs[Object.keys(subs)[0]];
  },
  mapApi: function(subs, methodName) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return Object.keys(subs).reduce(function(output, propKey) {
        var _a;
        if (subs[propKey][methodName]) {
          args[0] && args[0][propKey] !== void 0 ? output[propKey] = subs[propKey][methodName](args[0][propKey]) : output[propKey] = (_a = subs[propKey])[methodName].apply(_a, args);
        }
        return output;
      }, {});
    };
  },
  setProp: function(output, name, v2) {
    return output[name] = v2;
  },
  startActions: function(actions, starter) {
    return Object.keys(actions).reduce(function(subs, key) {
      subs[key] = starter(actions[key], key);
      return subs;
    }, {});
  }
});
var parallel = multi({
  getOutput: function() {
    return [];
  },
  getCount: function(subs) {
    return subs.length;
  },
  getFirst: function(subs) {
    return subs[0];
  },
  mapApi: function(subs, methodName) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subs.map(function(sub, i) {
        if (sub[methodName]) {
          return Array.isArray(args[0]) ? sub[methodName](args[0][i]) : sub[methodName].apply(sub, args);
        }
      });
    };
  },
  setProp: function(output, name, v2) {
    return output[name] = v2;
  },
  startActions: function(actions, starter) {
    return actions.map(function(action2, i) {
      return starter(action2, i);
    });
  }
});
var parallel$1 = function() {
  var actions = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    actions[_i] = arguments[_i];
  }
  return parallel(actions);
};
var createVectorTests = function(typeTests) {
  var testNames = Object.keys(typeTests);
  var isVectorProp = function(prop, key) {
    return prop !== void 0 && !typeTests[key](prop);
  };
  var getVectorKeys = function(props) {
    return testNames.reduce(function(vectorKeys, key) {
      if (isVectorProp(props[key], key)) vectorKeys.push(key);
      return vectorKeys;
    }, []);
  };
  var testVectorProps = function(props) {
    return props && testNames.some(function(key) {
      return isVectorProp(props[key], key);
    });
  };
  return { getVectorKeys, testVectorProps };
};
var unitTypes = [px, percent, degrees, vh, vw];
var findUnitType = function(prop) {
  return unitTypes.find(function(type) {
    return type.test(prop);
  });
};
var isUnitProp = function(prop) {
  return Boolean(findUnitType(prop));
};
var createAction = function(action2, props) {
  return action2(props);
};
var reduceArrayValue = function(i) {
  return function(props, key) {
    props[key] = props[key][i];
    return props;
  };
};
var createArrayAction = function(action2, props, vectorKeys) {
  var firstVectorKey = vectorKeys[0];
  var actionList = props[firstVectorKey].map(function(v2, i) {
    var childActionProps = vectorKeys.reduce(reduceArrayValue(i), __assign({}, props));
    return getActionCreator(v2)(action2, childActionProps);
  });
  return parallel$1.apply(void 0, actionList);
};
var reduceObjectValue = function(key) {
  return function(props, propKey) {
    props[propKey] = props[propKey][key];
    return props;
  };
};
var createObjectAction = function(action2, props, vectorKeys) {
  var firstVectorKey = vectorKeys[0];
  var actionMap = Object.keys(props[firstVectorKey]).reduce(function(map, key) {
    var childActionProps = vectorKeys.reduce(reduceObjectValue(key), __assign({}, props));
    map[key] = getActionCreator(props[firstVectorKey][key])(action2, childActionProps);
    return map;
  }, {});
  return composite(actionMap);
};
var createUnitAction = function(action2, _a) {
  var from = _a.from, to = _a.to, props = __rest(_a, ["from", "to"]);
  var unitType = findUnitType(from) || findUnitType(to);
  var transform = unitType.transform, parse = unitType.parse;
  return action2(__assign({}, props, { from: typeof from === "string" ? parse(from) : from, to: typeof to === "string" ? parse(to) : to })).pipe(transform);
};
var createMixerAction = function(mixer) {
  return function(action2, _a) {
    var from = _a.from, to = _a.to, props = __rest(_a, ["from", "to"]);
    return action2(__assign({}, props, { from: 0, to: 1 })).pipe(mixer(from, to));
  };
};
var createColorAction = createMixerAction(mixColor);
var createComplexAction = createMixerAction(mixComplex);
var createVectorAction = function(action2, typeTests) {
  var _a = createVectorTests(typeTests), testVectorProps = _a.testVectorProps, getVectorKeys = _a.getVectorKeys;
  var vectorAction = function(props) {
    var isVector = testVectorProps(props);
    if (!isVector) return action2(props);
    var vectorKeys = getVectorKeys(props);
    var testKey = vectorKeys[0];
    var testProp = props[testKey];
    return getActionCreator(testProp)(action2, props, vectorKeys);
  };
  return vectorAction;
};
var getActionCreator = function(prop) {
  if (typeof prop === "number") {
    return createAction;
  } else if (Array.isArray(prop)) {
    return createArrayAction;
  } else if (isUnitProp(prop)) {
    return createUnitAction;
  } else if (color.test(prop)) {
    return createColorAction;
  } else if (complex.test(prop)) {
    return createComplexAction;
  } else if (typeof prop === "object") {
    return createObjectAction;
  } else {
    return createAction;
  }
};
var decay = function(props) {
  if (props === void 0) {
    props = {};
  }
  return action(function(_a) {
    var complete = _a.complete, update = _a.update;
    var _b = props.velocity, velocity = _b === void 0 ? 0 : _b, _c = props.from, from = _c === void 0 ? 0 : _c, _d = props.power, power = _d === void 0 ? 0.8 : _d, _e = props.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = props.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = props.modifyTarget;
    var elapsed = 0;
    var amplitude = power * velocity;
    var idealTarget = Math.round(from + amplitude);
    var target = typeof modifyTarget === "undefined" ? idealTarget : modifyTarget(idealTarget);
    var process2 = framesync_es_default.update(function(_a2) {
      var frameDelta = _a2.delta;
      elapsed += frameDelta;
      var delta = -amplitude * Math.exp(-elapsed / timeConstant);
      var isMoving = delta > restDelta || delta < -restDelta;
      var current = isMoving ? target + delta : target;
      update(current);
      if (!isMoving) {
        cancelSync2.update(process2);
        complete();
      }
    }, true);
    return {
      stop: function() {
        return cancelSync2.update(process2);
      }
    };
  });
};
var vectorDecay = createVectorAction(decay, {
  from: number.test,
  modifyTarget: function(func) {
    return typeof func === "function";
  },
  velocity: number.test
});
var spring = function(props) {
  if (props === void 0) {
    props = {};
  }
  return action(function(_a) {
    var update = _a.update, complete = _a.complete;
    var _b = props.velocity, velocity = _b === void 0 ? 0 : _b;
    var _c = props.from, from = _c === void 0 ? 0 : _c, _d = props.to, to = _d === void 0 ? 0 : _d, _e = props.stiffness, stiffness = _e === void 0 ? 100 : _e, _f = props.damping, damping = _f === void 0 ? 10 : _f, _g = props.mass, mass = _g === void 0 ? 1 : _g, _h = props.restSpeed, restSpeed = _h === void 0 ? 0.01 : _h, _j = props.restDelta, restDelta = _j === void 0 ? 0.01 : _j;
    var initialVelocity = velocity ? -(velocity / 1e3) : 0;
    var t2 = 0;
    var delta = to - from;
    var position = from;
    var prevPosition = position;
    var process2 = framesync_es_default.update(function(_a2) {
      var timeDelta = _a2.delta;
      t2 += timeDelta;
      var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
      var angularFreq = Math.sqrt(stiffness / mass) / 1e3;
      prevPosition = position;
      if (dampingRatio < 1) {
        var envelope = Math.exp(-dampingRatio * angularFreq * t2);
        var expoDecay = angularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
        position = to - envelope * ((initialVelocity + dampingRatio * angularFreq * delta) / expoDecay * Math.sin(expoDecay * t2) + delta * Math.cos(expoDecay * t2));
      } else {
        var envelope = Math.exp(-angularFreq * t2);
        position = to - envelope * (delta + (initialVelocity + angularFreq * delta) * t2);
      }
      velocity = velocityPerSecond(position - prevPosition, timeDelta);
      var isBelowVelocityThreshold = Math.abs(velocity) <= restSpeed;
      var isBelowDisplacementThreshold = Math.abs(to - position) <= restDelta;
      if (isBelowVelocityThreshold && isBelowDisplacementThreshold) {
        position = to;
        update(position);
        cancelSync2.update(process2);
        complete();
      } else {
        update(position);
      }
    }, true);
    return {
      stop: function() {
        return cancelSync2.update(process2);
      }
    };
  });
};
var vectorSpring = createVectorAction(spring, {
  from: number.test,
  to: number.test,
  stiffness: number.test,
  damping: number.test,
  mass: number.test,
  velocity: number.test
});
var inertia = function(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 700 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget;
  return action(function(_a2) {
    var update = _a2.update, complete = _a2.complete;
    var current = value(from);
    var activeAnimation;
    var isSpring = false;
    var isLessThanMin = function(v2) {
      return min !== void 0 && v2 <= min;
    };
    var isMoreThanMax = function(v2) {
      return max !== void 0 && v2 >= max;
    };
    var isOutOfBounds = function(v2) {
      return isLessThanMin(v2) || isMoreThanMax(v2);
    };
    var isTravellingAwayFromBounds = function(v2, currentVelocity) {
      return isLessThanMin(v2) && currentVelocity < 0 || isMoreThanMax(v2) && currentVelocity > 0;
    };
    var startAnimation = function(animation2, next) {
      activeAnimation && activeAnimation.stop();
      activeAnimation = animation2.start({
        update: function(v2) {
          return current.update(v2);
        },
        complete: function() {
          if (next) {
            next();
            return;
          }
          complete();
        }
      });
    };
    var startSpring = function(props) {
      isSpring = true;
      startAnimation(vectorSpring(__assign({}, props, { to: isLessThanMin(props.from) ? min : max, stiffness: bounceStiffness, damping: bounceDamping, restDelta })));
    };
    current.subscribe(function(v2) {
      update(v2);
      var currentVelocity = current.getVelocity();
      if (activeAnimation && !isSpring && isTravellingAwayFromBounds(v2, currentVelocity)) {
        startSpring({ from: v2, velocity: currentVelocity });
      }
    });
    if (isOutOfBounds(from)) {
      startSpring({ from, velocity });
    } else if (velocity !== 0) {
      var animation = vectorDecay({
        from,
        velocity,
        timeConstant,
        power,
        restDelta: isOutOfBounds(from) ? 20 : restDelta,
        modifyTarget
      });
      startAnimation(animation, function() {
        var v2 = current.get();
        if (isOutOfBounds(v2)) {
          startSpring({ from: v2, velocity: current.getVelocity() });
        } else {
          complete();
        }
      });
    } else {
      complete();
    }
    return {
      stop: function() {
        return activeAnimation && activeAnimation.stop();
      }
    };
  });
};
var index = createVectorAction(inertia, {
  from: number.test,
  velocity: number.test,
  min: number.test,
  max: number.test,
  damping: number.test,
  stiffness: number.test,
  modifyTarget: function(func) {
    return typeof func === "function";
  }
});
var scrubber = function(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.ease, ease = _d === void 0 ? linear : _d, _e = _a.reverseEase, reverseEase = _e === void 0 ? false : _e;
  if (reverseEase) {
    ease = createReversedEasing(ease);
  }
  return action(function(_a2) {
    var update = _a2.update;
    return {
      seek: function(progress$$1) {
        return update(progress$$1);
      }
    };
  }).pipe(ease, function(v2) {
    return mix(from, to, v2);
  });
};
var vectorScrubber = createVectorAction(scrubber, {
  ease: function(func) {
    return typeof func === "function";
  },
  from: number.test,
  to: number.test
});
var clampProgress2 = clamp$1(0, 1);
var tween = function(props) {
  if (props === void 0) {
    props = {};
  }
  return action(function(_a) {
    var update = _a.update, complete = _a.complete;
    var _b = props.duration, duration = _b === void 0 ? 300 : _b, _c = props.ease, ease = _c === void 0 ? easeOut : _c, _d = props.flip, flip = _d === void 0 ? 0 : _d, _e = props.loop, loop = _e === void 0 ? 0 : _e, _f = props.yoyo, yoyo = _f === void 0 ? 0 : _f, _g = props.repeatDelay, repeatDelay = _g === void 0 ? 0 : _g;
    var _h = props.from, from = _h === void 0 ? 0 : _h, _j = props.to, to = _j === void 0 ? 1 : _j, _k = props.elapsed, elapsed = _k === void 0 ? 0 : _k, _l = props.flipCount, flipCount = _l === void 0 ? 0 : _l, _m = props.yoyoCount, yoyoCount = _m === void 0 ? 0 : _m, _o = props.loopCount, loopCount = _o === void 0 ? 0 : _o;
    var playhead = vectorScrubber({ from, to, ease }).start(update);
    var currentProgress = 0;
    var process2;
    var isActive = false;
    var reverseAnimation = function(reverseEase) {
      if (reverseEase === void 0) {
        reverseEase = false;
      }
      var _a2;
      _a2 = [to, from], from = _a2[0], to = _a2[1];
      playhead = vectorScrubber({ from, to, ease, reverseEase }).start(update);
    };
    var isTweenComplete = function() {
      var isComplete = isActive && elapsed > duration + repeatDelay;
      if (!isComplete) return false;
      if (isComplete && !loop && !flip && !yoyo) return true;
      elapsed = duration - (elapsed - repeatDelay);
      if (loop && loopCount < loop) {
        loopCount++;
        return false;
      } else if (flip && flipCount < flip) {
        flipCount++;
        reverseAnimation();
        return false;
      } else if (yoyo && yoyoCount < yoyo) {
        yoyoCount++;
        reverseAnimation(yoyoCount % 2 !== 0);
        return false;
      }
      return true;
    };
    var updateTween = function() {
      currentProgress = clampProgress2(progress(0, duration, elapsed));
      playhead.seek(currentProgress);
    };
    var startTimer = function() {
      isActive = true;
      process2 = framesync_es_default.update(function(_a2) {
        var delta = _a2.delta;
        elapsed += delta;
        updateTween();
        if (isTweenComplete()) {
          cancelSync2.update(process2);
          complete && framesync_es_default.update(complete, false, true);
        }
      }, true);
    };
    var stopTimer = function() {
      isActive = false;
      if (process2) cancelSync2.update(process2);
    };
    startTimer();
    return {
      isActive: function() {
        return isActive;
      },
      getElapsed: function() {
        return clamp$1(0, duration, elapsed);
      },
      getProgress: function() {
        return currentProgress;
      },
      stop: function() {
        stopTimer();
      },
      pause: function() {
        stopTimer();
        return this;
      },
      resume: function() {
        if (!isActive) startTimer();
        return this;
      },
      seek: function(newProgress) {
        elapsed = mix(0, duration, newProgress);
        framesync_es_default.update(updateTween, false, true);
        return this;
      },
      reverse: function() {
        reverseAnimation();
        return this;
      }
    };
  });
};
var clampProgress$1 = clamp$1(0, 1);
var physics = function(props) {
  if (props === void 0) {
    props = {};
  }
  return action(function(_a) {
    var complete = _a.complete, update = _a.update;
    var _b = props.acceleration, acceleration = _b === void 0 ? 0 : _b, _c = props.friction, friction = _c === void 0 ? 0 : _c, _d = props.velocity, velocity = _d === void 0 ? 0 : _d, springStrength = props.springStrength, to = props.to;
    var _e = props.restSpeed, restSpeed = _e === void 0 ? 1e-3 : _e, _f = props.from, from = _f === void 0 ? 0 : _f;
    var current = from;
    var process2 = framesync_es_default.update(function(_a2) {
      var delta = _a2.delta;
      var elapsed = Math.max(delta, 16);
      if (acceleration) velocity += velocityPerFrame(acceleration, elapsed);
      if (friction) velocity *= Math.pow(1 - friction, elapsed / 100);
      if (springStrength !== void 0 && to !== void 0) {
        var distanceToTarget = to - current;
        velocity += distanceToTarget * velocityPerFrame(springStrength, elapsed);
      }
      current += velocityPerFrame(velocity, elapsed);
      update(current);
      var isComplete = restSpeed !== false && (!velocity || Math.abs(velocity) <= restSpeed);
      if (isComplete) {
        cancelSync2.update(process2);
        complete();
      }
    }, true);
    return {
      set: function(v2) {
        current = v2;
        return this;
      },
      setAcceleration: function(v2) {
        acceleration = v2;
        return this;
      },
      setFriction: function(v2) {
        friction = v2;
        return this;
      },
      setSpringStrength: function(v2) {
        springStrength = v2;
        return this;
      },
      setSpringTarget: function(v2) {
        to = v2;
        return this;
      },
      setVelocity: function(v2) {
        velocity = v2;
        return this;
      },
      stop: function() {
        return cancelSync2.update(process2);
      }
    };
  });
};
var vectorPhysics = createVectorAction(physics, {
  acceleration: number.test,
  friction: number.test,
  velocity: number.test,
  from: number.test,
  to: number.test,
  springStrength: number.test
});
var listen = function(element, events, options) {
  return action(function(_a) {
    var update = _a.update;
    var eventNames = events.split(" ").map(function(eventName) {
      element.addEventListener(eventName, update, options);
      return eventName;
    });
    return {
      stop: function() {
        return eventNames.forEach(function(eventName) {
          return element.removeEventListener(eventName, update, options);
        });
      }
    };
  });
};
var defaultPointerPos = function() {
  return {
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    x: 0,
    y: 0
  };
};
var eventToPoint = function(e2, point2) {
  if (point2 === void 0) {
    point2 = defaultPointerPos();
  }
  point2.clientX = point2.x = e2.clientX;
  point2.clientY = point2.y = e2.clientY;
  point2.pageX = e2.pageX;
  point2.pageY = e2.pageY;
  return point2;
};
var points = [defaultPointerPos()];
var isTouchDevice = false;
if (typeof document !== "undefined") {
  updatePointsLocation = function(_a) {
    var touches = _a.touches;
    isTouchDevice = true;
    var numTouches = touches.length;
    points.length = 0;
    for (var i = 0; i < numTouches; i++) {
      var thisTouch = touches[i];
      points.push(eventToPoint(thisTouch));
    }
  };
  listen(document, "touchstart touchmove", {
    passive: true,
    capture: true
  }).start(updatePointsLocation);
}
var updatePointsLocation;
var multitouch = function(_a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.preventDefault, preventDefault = _c === void 0 ? true : _c, _d = _b.scale, scale2 = _d === void 0 ? 1 : _d, _e = _b.rotate, rotate = _e === void 0 ? 0 : _e;
  return action(function(_a2) {
    var update = _a2.update;
    var output = {
      touches: points,
      scale: scale2,
      rotate
    };
    var initialDistance = 0;
    var initialRotation = 0;
    var isGesture = points.length > 1;
    if (isGesture) {
      var firstTouch = points[0], secondTouch = points[1];
      initialDistance = distance(firstTouch, secondTouch);
      initialRotation = angle(firstTouch, secondTouch);
    }
    var updatePoint = function() {
      if (isGesture) {
        var firstTouch2 = points[0], secondTouch2 = points[1];
        var newDistance = distance(firstTouch2, secondTouch2);
        var newRotation = angle(firstTouch2, secondTouch2);
        output.scale = scale2 * (newDistance / initialDistance);
        output.rotate = rotate + (newRotation - initialRotation);
      }
      update(output);
    };
    var onMove = function(e2) {
      if (preventDefault || e2.touches.length > 1) e2.preventDefault();
      framesync_es_default.update(updatePoint);
    };
    var updateOnMove = listen(document, "touchmove", {
      passive: !preventDefault
    }).start(onMove);
    if (isTouchDevice) framesync_es_default.update(updatePoint);
    return {
      stop: function() {
        cancelSync2.update(updatePoint);
        updateOnMove.stop();
      }
    };
  });
};
var getIsTouchDevice = function() {
  return isTouchDevice;
};
var point = defaultPointerPos();
var isMouseDevice = false;
if (typeof document !== "undefined") {
  updatePointLocation = function(e2) {
    isMouseDevice = true;
    eventToPoint(e2, point);
  };
  listen(document, "mousedown mousemove", true).start(updatePointLocation);
}
var updatePointLocation;
var mouse = function(_a) {
  var _b = (_a === void 0 ? {} : _a).preventDefault, preventDefault = _b === void 0 ? true : _b;
  return action(function(_a2) {
    var update = _a2.update;
    var updatePoint = function() {
      return update(point);
    };
    var onMove = function(e2) {
      if (preventDefault) e2.preventDefault();
      framesync_es_default.update(updatePoint);
    };
    var updateOnMove = listen(document, "mousemove").start(onMove);
    if (isMouseDevice) framesync_es_default.update(updatePoint);
    return {
      stop: function() {
        cancelSync2.update(updatePoint);
        updateOnMove.stop();
      }
    };
  });
};
var getFirstTouch = function(_a) {
  var firstTouch = _a[0];
  return firstTouch;
};
var pointer = function(props) {
  if (props === void 0) {
    props = {};
  }
  return getIsTouchDevice() ? multitouch(props).pipe(function(_a) {
    var touches = _a.touches;
    return touches;
  }, getFirstTouch) : mouse(props);
};
var index$1 = function(_a) {
  if (_a === void 0) {
    _a = {};
  }
  var x2 = _a.x, y2 = _a.y, props = __rest(_a, ["x", "y"]);
  if (x2 !== void 0 || y2 !== void 0) {
    var applyXOffset_1 = applyOffset(x2 || 0);
    var applyYOffset_1 = applyOffset(y2 || 0);
    var delta_1 = { x: 0, y: 0 };
    return pointer(props).pipe(function(point2) {
      delta_1.x = applyXOffset_1(point2.x);
      delta_1.y = applyYOffset_1(point2.y);
      return delta_1;
    });
  } else {
    return pointer(props);
  }
};
var appendUnit = function(unit) {
  return function(v2) {
    return "" + v2 + unit;
  };
};
var steps4 = function(st, min, max) {
  if (min === void 0) {
    min = 0;
  }
  if (max === void 0) {
    max = 1;
  }
  return function(v2) {
    var current = progress(min, max, v2);
    return mix(min, max, stepProgress(st, current));
  };
};
var transformMap = function(childTransformers) {
  return function(v2) {
    var output = __assign({}, v2);
    for (var key in childTransformers) {
      if (childTransformers.hasOwnProperty(key)) {
        var childTransformer = childTransformers[key];
        output[key] = childTransformer(v2[key]);
      }
    }
    return output;
  };
};
var transformers = Object.freeze({
  applyOffset,
  clamp: clamp$1,
  conditional,
  interpolate,
  blendArray: mixArray,
  blendColor: mixColor,
  pipe,
  smooth,
  snap,
  generateStaticSpring: springForce,
  nonlinearSpring: springForceExpo,
  linearSpring: springForceLinear,
  wrap: wrap$1,
  appendUnit,
  steps: steps4,
  transformMap
});

// node_modules/react-scroll-snap-anime-slider/dist/index.module.js
var c2 = function(t2, e2) {
  return c2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
    t3.__proto__ = e3;
  } || function(t3, e3) {
    for (var i in e3) Object.prototype.hasOwnProperty.call(e3, i) && (t3[i] = e3[i]);
  }, c2(t2, e2);
};
function d(t2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i() {
    this.constructor = t2;
  }
  c2(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i.prototype = e2.prototype, new i());
}
var p = function() {
  return p = Object.assign || function(t2) {
    for (var e2, i = 1, r = arguments.length; i < r; i++) for (var n in e2 = arguments[i]) Object.prototype.hasOwnProperty.call(e2, n) && (t2[n] = e2[n]);
    return t2;
  }, p.apply(this, arguments);
};
function u(t2, e2) {
  var i = {};
  for (var r in t2) Object.prototype.hasOwnProperty.call(t2, r) && e2.indexOf(r) < 0 && (i[r] = t2[r]);
  if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
    var n = 0;
    for (r = Object.getOwnPropertySymbols(t2); n < r.length; n++) e2.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, r[n]) && (i[r[n]] = t2[r[n]]);
  }
  return i;
}
var h = { slideHeight: 0, slideWidth: 0, visibleSlides: 1, step: 1, currentSlide: 0, freeScroll: false, inertiaPower: 0.4, inertiaStopSpeed: 800 };
var f = p(p({}, h), { totalSlides: 0, updateContext: function() {
}, subscribers: [], slideTo: function() {
} });
var v = import_react.default.createContext(f);
function y(t2, e2) {
  return t2 + e2;
}
function m() {
  for (var t2 = [], e2 = 0; e2 < arguments.length; e2++) t2[e2] = arguments[e2];
  for (var i = [], r = 0; r < t2.length; ++r) {
    var n = t2[r];
    null != n && "boolean" != typeof n && (Array.isArray(n) ? i.push(m.apply(void 0, n)) : i.push(n));
  }
  return i.join(" ").replace(/\s+/g, " ").trim();
}
function x() {
  for (var t2, e2, i, r, n = [], s = 0; s < arguments.length; s++) n[s] = arguments[s];
  function o(t3, e3) {
    var n2;
    if (isNaN(t3) && isNaN(e3) && "number" == typeof t3 && "number" == typeof e3) return true;
    if (t3 === e3) return true;
    if ("function" == typeof t3 && "function" == typeof e3 || t3 instanceof Date && e3 instanceof Date || t3 instanceof RegExp && e3 instanceof RegExp || t3 instanceof String && e3 instanceof String || t3 instanceof Number && e3 instanceof Number) return t3.toString() === e3.toString();
    if (!(t3 instanceof Object && e3 instanceof Object)) return false;
    if (t3.isPrototypeOf(e3) || e3.isPrototypeOf(t3)) return false;
    if (t3.constructor !== e3.constructor) return false;
    if (t3.prototype !== e3.prototype) return false;
    if (i.indexOf(t3) > -1 || r.indexOf(e3) > -1) return false;
    for (n2 in e3) {
      if (e3.hasOwnProperty(n2) !== t3.hasOwnProperty(n2)) return false;
      if (typeof e3[n2] != typeof t3[n2]) return false;
    }
    for (n2 in t3) {
      if (e3.hasOwnProperty(n2) !== t3.hasOwnProperty(n2)) return false;
      if (typeof e3[n2] != typeof t3[n2]) return false;
      switch (typeof t3[n2]) {
        case "object":
        case "function":
          if (i.push(t3), r.push(e3), !o(t3[n2], e3[n2])) return false;
          i.pop(), r.pop();
          break;
        default:
          if (t3[n2] !== e3[n2]) return false;
      }
    }
    return true;
  }
  if (n.length < 1) return true;
  for (t2 = 1, e2 = n.length; t2 < e2; t2++) if (i = [], r = [], !o(n[0], n[t2])) return false;
  return true;
}
function b2(t2) {
  return Math.round(1e3 * t2) / 1e3;
}
var g = { slider: "slider__T8bxB", "slider-tray": "slider-tray__29SRr", "css-only": "css-only__i5pKg", slide: "slide__JLMug", "slide-inner-padding": "slide-inner-padding__xA7ms", "slide-inner-wrapper": "slide-inner-wrapper__2gLNh", "fixed-size": "fixed-size__jvUC5", "align-center": "align-center__CzoWZ", "snap-stop": "snap-stop__Sd4PZ", "scroll-snap": "scroll-snap__UJMQj", "slider-bar-track": "slider-bar-track__cpvry", "slider-bar-thumb": "slider-bar-thumb__aEFEz", "slider-bar-dot-group": "slider-bar-dot-group__O5G-9", "slider-dot-wrapper": "slider-dot-wrapper__hqKwO", "slider-dot": "slider-dot__BE48t", dynamic: "dynamic__FKSSN", active: "active__TNQVn" };
!function(t2, e2) {
  void 0 === e2 && (e2 = {});
  var i = e2.insertAt;
  if (t2 && "undefined" != typeof document) {
    var r = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
    n.type = "text/css", "top" === i && r.firstChild ? r.insertBefore(n, r.firstChild) : r.appendChild(n), n.styleSheet ? n.styleSheet.cssText = t2 : n.appendChild(document.createTextNode(t2));
  }
}(".slider__T8bxB{overflow:hidden;position:relative}.slider-tray__29SRr::-webkit-scrollbar{display:none}.slider-tray__29SRr.css-only__i5pKg{-webkit-overflow-scrolling:touch;display:flex;overflow-x:auto}.slide__JLMug{flex-shrink:0;scroll-snap-align:start;scroll-snap-stop:normal}.slide-inner-padding__xA7ms{position:relative}.slide-inner-wrapper__2gLNh.fixed-size__jvUC5{height:100%;left:0;position:absolute;top:0;width:100%}.slide__JLMug.align-center__CzoWZ{scroll-snap-align:center}.slide__JLMug.snap-stop__Sd4PZ{scroll-snap-stop:always}.slider-tray__29SRr.css-only__i5pKg.scroll-snap__UJMQj{scroll-behavior:smooth;scroll-snap-type:x mandatory}.slider-bar-track__cpvry{background-color:#eee;height:10px;position:relative}.slider-bar-thumb__aEFEz{background-color:#555;height:100%;left:0;position:absolute;top:0}.slider-bar-dot-group__O5G-9{display:flex;justify-content:center;position:relative}.slider-dot-wrapper__hqKwO{cursor:pointer;padding:5px}.slider-dot__BE48t{background-color:#555;border-radius:10rem;height:8px;width:8px}.slider-dot-wrapper__hqKwO:not(.dynamic__FKSSN) .slider-dot__BE48t{background-color:#ddd}.slider-dot-wrapper__hqKwO:not(.dynamic__FKSSN).active__TNQVn .slider-dot__BE48t{background-color:#666}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInN0eWxlLm1vZHVsZS5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBRUUsZUFBZ0IsQ0FEaEIsaUJBQ2tCLENBRXBCLHVDQUNFLFlBQWUsQ0FFakIsb0NBR0UsZ0NBQWlDLENBRmpDLFlBQWEsQ0FDYixlQUNtQyxDQUVyQyxjQUNFLGFBQWMsQ0FDZCx1QkFBd0IsQ0FDeEIsdUJBQTBCLENBRTVCLDRCQUNFLGlCQUFvQixDQUV0Qiw4Q0FHRSxXQUFZLENBQ1osTUFBTyxDQUhQLGlCQUFrQixDQUlsQixLQUFNLENBSE4sVUFHUSxDQUVWLGtDQUNFLHdCQUEyQixDQUU3QiwrQkFDRSx1QkFBMEIsQ0FFNUIsdURBQ0Usc0JBQXVCLENBQ3ZCLDRCQUErQixDQUVqQyx5QkFDRSxxQkFBc0IsQ0FFdEIsV0FBWSxDQURaLGlCQUNjLENBRWhCLHlCQUtFLHFCQUFzQixDQUR0QixXQUFZLENBRlosTUFBTyxDQURQLGlCQUFrQixDQUVsQixLQUV3QixDQUUxQiw2QkFDRSxZQUFhLENBQ2Isc0JBQXVCLENBQ3ZCLGlCQUFvQixDQUV0QiwyQkFFRSxjQUFlLENBRGYsV0FDaUIsQ0FFbkIsbUJBSUUscUJBQXNCLENBRHRCLG1CQUFvQixDQUZwQixVQUFXLENBQ1gsU0FFd0IsQ0FFMUIsbUVBQ0UscUJBQXdCLENBRTFCLGlGQUNFLHFCQUF3QiIsImZpbGUiOiJzdHlsZS5tb2R1bGUuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5zbGlkZXIge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG92ZXJmbG93OiBoaWRkZW47IH1cblxuLnNsaWRlci10cmF5Ojotd2Via2l0LXNjcm9sbGJhciB7XG4gIGRpc3BsYXk6IG5vbmU7IH1cblxuLnNsaWRlci10cmF5LmNzcy1vbmx5IHtcbiAgZGlzcGxheTogZmxleDtcbiAgb3ZlcmZsb3cteDogYXV0bztcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoOyB9XG5cbi5zbGlkZSB7XG4gIGZsZXgtc2hyaW5rOiAwO1xuICBzY3JvbGwtc25hcC1hbGlnbjogc3RhcnQ7XG4gIHNjcm9sbC1zbmFwLXN0b3A6IG5vcm1hbDsgfVxuXG4uc2xpZGUtaW5uZXItcGFkZGluZyB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxuXG4uc2xpZGUtaW5uZXItd3JhcHBlci5maXhlZC1zaXplIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBsZWZ0OiAwO1xuICB0b3A6IDA7IH1cblxuLnNsaWRlLmFsaWduLWNlbnRlciB7XG4gIHNjcm9sbC1zbmFwLWFsaWduOiBjZW50ZXI7IH1cblxuLnNsaWRlLnNuYXAtc3RvcCB7XG4gIHNjcm9sbC1zbmFwLXN0b3A6IGFsd2F5czsgfVxuXG4uc2xpZGVyLXRyYXkuY3NzLW9ubHkuc2Nyb2xsLXNuYXAge1xuICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcbiAgc2Nyb2xsLXNuYXAtdHlwZTogeCBtYW5kYXRvcnk7IH1cblxuLnNsaWRlci1iYXItdHJhY2sge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGhlaWdodDogMTBweDsgfVxuXG4uc2xpZGVyLWJhci10aHVtYiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMDtcbiAgdG9wOiAwO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1NTU7IH1cblxuLnNsaWRlci1iYXItZG90LWdyb3VwIHtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxuXG4uc2xpZGVyLWRvdC13cmFwcGVyIHtcbiAgcGFkZGluZzogNXB4O1xuICBjdXJzb3I6IHBvaW50ZXI7IH1cblxuLnNsaWRlci1kb3Qge1xuICBoZWlnaHQ6IDhweDtcbiAgd2lkdGg6IDhweDtcbiAgYm9yZGVyLXJhZGl1czogMTByZW07XG4gIGJhY2tncm91bmQtY29sb3I6ICM1NTU7IH1cblxuLnNsaWRlci1kb3Qtd3JhcHBlcjpub3QoLmR5bmFtaWMpIC5zbGlkZXItZG90IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDsgfVxuXG4uc2xpZGVyLWRvdC13cmFwcGVyOm5vdCguZHluYW1pYykuYWN0aXZlIC5zbGlkZXItZG90IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzY2NjsgfVxuIl19 */");
var S = "rssas";
function N(t2) {
  return [S + "-" + t2, g[t2]];
}
var C = function(e2) {
  function i(t2) {
    var i2 = e2.call(this, t2) || this;
    return i2.updateContext = function(t3) {
      i2.setState({ context: p(p({}, i2.state.context), t3) });
    }, i2.state = { context: i2.extractContextProps(i2.props) }, i2;
  }
  return d(i, e2), i.prototype.extractContextProps = function(t2) {
    var e3, i2 = Object.assign({}, f);
    for (e3 in i2) null != t2[e3] && (i2[e3] = this.props[e3]);
    return i2.step = this.validateStep(t2), i2.updateContext = this.updateContext, i2.subscribers = [], i2.onSlide = t2.onSlide, i2.slideMargin = t2.slideMargin, i2.snapAnimation = t2.snapAnimation, i2.trayPadding = t2.trayPadding, i2;
  }, i.prototype.compareContextProps = function(t2, e3) {
    for (var i2 = 0, r = ["totalSlides", "visibleSlides", "step", "slideHeight", "slideWidth", "slideMargin", "trayPadding", "freeScroll", "onSlide", "snapAnimation", "inertiaPower", "inertiaStopSpeed"]; i2 < r.length; i2++) {
      var n = r[i2];
      if (t2[n] !== e3[n]) return false;
    }
    return true;
  }, i.prototype.validateStep = function(t2) {
    return t2.step > 0 ? t2.step < t2.visibleSlides ? t2.step : t2.visibleSlides : 1;
  }, i.prototype.componentDidUpdate = function(t2, e3, i2) {
    this.compareContextProps(t2, this.props) || this.setState({ context: this.extractContextProps(this.props) });
  }, i.prototype.render = function() {
    var e3 = this.props, i2 = e3.className, r = e3.children;
    e3.currentSlide, e3.freeScroll, e3.slideHeight, e3.slideWidth, e3.step, e3.totalSlides, e3.visibleSlides, e3.slideMargin, e3.onSlide, e3.trayPadding, e3.inertiaPower, e3.snapAnimation, e3.inertiaStopSpeed;
    var n = u(e3, ["className", "children", "currentSlide", "freeScroll", "slideHeight", "slideWidth", "step", "totalSlides", "visibleSlides", "slideMargin", "onSlide", "trayPadding", "inertiaPower", "snapAnimation", "inertiaStopSpeed"]);
    return import_react.default.createElement("div", p({}, n, { className: m(N("wrapper"), i2) }), import_react.default.createElement(v.Provider, { value: p({}, this.state.context) }, r));
  }, i.defaultProps = p({}, h), i;
}(import_react.default.Component);
var Q = function(e2) {
  function c3(l) {
    var a2 = e2.call(this, l) || this;
    return a2.sliderTrayRef = import_react.default.createRef(), a2.tempCurrentSlide = 0, a2.sliderDidSlided = false, a2.onScroll = function(t2) {
      var e3 = a2.getTrayState();
      if (e3) {
        for (var i = e3.trayWidth, r = e3.innerTrayWidth, n = e3.slideWidth, s = e3.scrollLeft, o = a2.context.currentSlide, l2 = 0; l2 < a2.context.subscribers.length; ++l2) a2.context.subscribers[l2](r, n, s);
        a2.updateSlideIndex(e3), a2.context.onSlide && a2.context.onSlide({ scrollLeft: s, currentSlide: o, slideWidth: n, trayWidth: i });
      }
    }, a2.onWheel = function(t2) {
      var e3;
      if (a2.stopAnimeActions(), a2.sliderTrayRef.current) {
        var i = a2.sliderTrayRef.current;
        !a2.context.freeScroll && (e3 = i.classList).add.apply(e3, N("scroll-snap"));
      }
    }, a2.onTouchstart = function(t2) {
      a2.stopTrackingActions();
    }, a2.startTracking = function(t2) {
      t2.preventDefault();
      var e3 = a2.getScrollMax();
      if (a2.stopTrackingActions(), a2.stopAnimeActions(), a2.sliderTrayRef.current && e3 > 0) {
        var s = a2.sliderTrayRef.current, o = s.scrollLeft, l2 = o;
        a2.sliderDidSlided = false, a2.scrollValue = value(o, function(t3) {
          a2.sliderDidSlided && s.scrollTo(t3, 0);
        }), a2.pointerAction = index$1({ x: 0, y: 0 }).pipe(function(t3) {
          var i, r = l2 - t3.x;
          return 0 == t3.x || a2.sliderDidSlided || (a2.sliderDidSlided = true, !a2.context.freeScroll && (i = s.classList).remove.apply(i, N("scroll-snap"))), r < 0 ? (l2 = t3.x, { x: 0, y: t3.y }) : r > e3 ? (l2 = e3 + t3.x, { x: e3, y: t3.y }) : { x: r, y: t3.y };
        }).start({ update: function(t3) {
          a2.scrollValue.update(t3.x);
        } }), a2.mouseUpAction = listen(window.document, "mouseup").start(a2.stopTracking), window.addEventListener("touchstart", a2.onTouchstart, false);
      }
    }, a2.stopTracking = function(t2) {
      if (a2.pointerAction && a2.sliderTrayRef.current) {
        var e3 = a2.sliderTrayRef.current, i = a2.getScrollMax(), r = a2.scrollValue.get(), n = a2.scrollValue.getVelocity(), l2 = false, c4 = a2.context.inertiaStopSpeed, d2 = function() {
          var t3;
          a2.snapAction = void 0, !a2.context.freeScroll && (t3 = e3.classList).add.apply(t3, N("scroll-snap"));
        }, p2 = function(t3, e4) {
          return tween({ from: t3, to: e4, duration: 300, ease: a2.getEase() }).start({ update: function(t4) {
            return a2.scrollValue.update(t4);
          }, complete: d2 });
        };
        if (a2.stopTrackingActions(), 0 === n) {
          if (!a2.context.freeScroll) {
            var u2 = a2.getSnapScrollValue(r, n);
            Math.abs(r - u2) > 0.5 ? a2.snapAction = p2(r, u2) : d2();
          }
          return;
        }
        var h2 = false, f2 = index({ from: r, velocity: n, power: a2.context.inertiaPower, restDelta: 0.4, timeConstant: 500 }).while(function(t3) {
          return !l2;
        }).pipe(function(t3) {
          return t3 < 0 ? (l2 = true, 0) : t3 > i ? (l2 = true, i) : t3;
        }).start({ update: function(t3) {
          if (h2) {
            var e4 = a2.scrollValue.getVelocity();
            if (a2.scrollValue.update(t3), Math.abs(e4) < c4 && !a2.context.freeScroll) {
              f2.stop(), a2.inertiaAction = void 0;
              var i2 = a2.getSnapScrollValue(t3, e4);
              a2.snapAction = p2(t3, i2);
            }
          } else h2 = true;
        }, complete: d2 });
        a2.inertiaAction = f2;
      }
    }, a2;
  }
  return d(c3, e2), c3.prototype.getTrayState = function() {
    if (this.sliderTrayRef.current) {
      var t2 = this.sliderTrayRef.current, e3 = t2.scrollLeft, i = t2.offsetWidth, r = Number(window.getComputedStyle(t2).paddingLeft.replace("px", "")), n = null == this.context.trayPadding ? i : i - 2 * r, s = n / this.context.visibleSlides;
      return { trayElement: t2, scrollLeft: e3, trayWidth: i, innerTrayWidth: n, trayPaddingX: r, slideWidth: s, slideCount: t2.childElementCount, currentSlide: Math.round(e3 / s) };
    }
  }, c3.prototype.updateSlideIndex = function(t2) {
    if (void 0 === t2 && (t2 = this.getTrayState()), t2) {
      var e3 = t2.currentSlide;
      this.tempCurrentSlide !== e3 && (this.tempCurrentSlide = e3, this.context.updateContext({ currentSlide: this.tempCurrentSlide }));
    }
  }, c3.prototype.slideTo = function(t2, e3) {
    var i, r = this;
    void 0 === e3 && (e3 = true);
    var n = this.getTrayState();
    if (n) {
      this.stopAnimeActions();
      var s = n.trayElement, l = n.scrollLeft, a2 = t2 * n.slideWidth;
      !this.context.freeScroll && (i = s.classList).remove.apply(i, N("scroll-snap")), this.snapAction = tween({ from: l, to: a2, duration: e3 ? 300 : 0, ease: this.getEase() }).start({ update: function(t3) {
        s.scrollTo(t3, 0);
      }, complete: function() {
        var t3;
        r.snapAction = void 0, !r.context.freeScroll && (t3 = s.classList).add.apply(t3, N("scroll-snap"));
      } });
    }
  }, c3.prototype.stopTrackingActions = function() {
    var t2, e3;
    null === (t2 = this.pointerAction) || void 0 === t2 || t2.stop(), this.pointerAction = void 0, null === (e3 = this.mouseUpAction) || void 0 === e3 || e3.stop(), this.mouseUpAction = void 0, window.removeEventListener("touchstart", this.onTouchstart, false);
  }, c3.prototype.stopAnimeActions = function() {
    this.inertiaAction && (this.inertiaAction.stop(), this.inertiaAction = void 0), this.snapAction && (this.snapAction.stop(), this.snapAction = void 0);
  }, c3.prototype.applyOverdrag = function(t2, e3) {
    var i = t2;
    return t2 < 0 && (i = calc.getValueFromProgress(0, t2, 0.1)), t2 > e3 && (i = calc.getValueFromProgress(e3, t2, 0.1)), i;
  }, c3.prototype.getScrollMax = function() {
    var t2 = this.getTrayState();
    return t2 ? t2.slideWidth * (t2.slideCount - this.context.visibleSlides) : 0;
  }, c3.prototype.getSnapScrollValue = function(t2, e3) {
    var i = t2, r = this.getTrayState();
    if (r) {
      var n = r.slideWidth, s = r.slideCount, o = 0;
      (o = e3 > 0 ? Math.ceil(t2 / n) : e3 < 0 ? Math.floor(t2 / n) : Math.round(t2 / n)) <= s && (i = o * n);
    }
    return i;
  }, c3.prototype.getEase = function() {
    if (this.context.snapAnimation) {
      if ("string" != typeof this.context.snapAnimation) return easing_es_exports.cubicBezier.apply(easing_es_exports, this.context.snapAnimation);
      if ("easeInOut" === this.context.snapAnimation) return easing_es_exports.easeInOut;
      if ("easeIn" === this.context.snapAnimation) return easing_es_exports.easeIn;
    }
    return easing_es_exports.easeOut;
  }, c3.prototype.handleOnClickCapture = function(t2) {
    this.sliderDidSlided && (t2.preventDefault(), t2.stopPropagation());
  }, c3.prototype.componentDidUpdate = function(t2, e3, i) {
    var r = this;
    this.context.slideTo = function(t3) {
      return r.slideTo(t3, true);
    };
  }, c3.prototype.componentDidMount = function() {
    var t2 = this;
    if (this.sliderTrayRef.current) {
      var e3 = this.sliderTrayRef.current;
      this.mouseDownAction = listen(e3, "mousedown").start(this.startTracking), e3.addEventListener("scroll", this.onScroll, false), e3.addEventListener("mousewheel", this.onWheel, false), e3.addEventListener("DOMMouseScroll", this.onWheel, false);
    }
    this.tempCurrentSlide !== this.context.currentSlide && this.slideTo(this.context.currentSlide, false), this.context.slideTo = function(e4) {
      return t2.slideTo(e4, true);
    };
  }, c3.prototype.componentWillUnmount = function() {
    var t2;
    if (this.sliderTrayRef.current) {
      var e3 = this.sliderTrayRef.current;
      this.stopTrackingActions(), this.stopAnimeActions(), null === (t2 = this.mouseDownAction) || void 0 === t2 || t2.stop(), e3.removeEventListener("scroll", this.onScroll, false), e3.removeEventListener("mousewheel", this.onWheel, false), e3.removeEventListener("DOMMouseScroll", this.onWheel, false);
    }
  }, c3.prototype.render = function() {
    var e3 = this.props, i = e3.children, r = e3.className, n = e3.trayProps, s = u(e3, ["children", "className", "trayProps"]), o = {};
    return this.context.slideMargin && (o.marginLeft = "-" + this.context.slideMargin, o.marginRight = "-" + this.context.slideMargin), null != this.context.trayPadding && (o.paddingLeft = this.context.trayPadding, o.paddingRight = this.context.trayPadding), import_react.default.createElement("div", p({}, s, { className: m(N("slider"), r) }), import_react.default.createElement("div", p({}, n, { className: m(N("slider-tray"), N("css-only"), this.context.freeScroll ? "" : N("scroll-snap"), null == n ? void 0 : n.className), style: p(p({}, null == n ? void 0 : n.style), o), ref: this.sliderTrayRef, onClickCapture: this.handleOnClickCapture.bind(this) }), i));
  }, c3;
}(import_react.Component);
Q.contextType = v;
var I = function(e2) {
  function i(t2) {
    var i2 = e2.call(this, t2) || this;
    return i2.state = {}, i2;
  }
  return d(i, e2), i.prototype.render = function() {
    var e3 = this.props, i2 = e3.children, r = e3.style, n = e3.className, s = e3.innerMarginDivProps, o = e3.innerPaddingDivProps, l = e3.innerWrapperDivProps, a2 = u(e3, ["children", "style", "className", "innerMarginDivProps", "innerPaddingDivProps", "innerWrapperDivProps"]), c3 = this.context, d2 = c3.slideHeight, h2 = c3.slideWidth, f2 = c3.visibleSlides, v2 = d2 > 0 && h2 > 0 ? d2 / h2 * 100 : 0, y2 = p({ width: (f2 > 0 ? 100 / f2 : 100) + "%", scrollMargin: null != this.context.trayPadding && this.context.visibleSlides % 2 == 0 ? "0 ".concat(this.context.trayPadding) : "" }, r), x2 = p({ paddingBottom: v2 > 0 ? v2 + "%" : "" }, null == o ? void 0 : o.style), b3 = p({}, null == s ? void 0 : s.style);
    null != this.context.slideMargin && (b3.marginLeft = this.context.slideMargin, b3.marginRight = this.context.slideMargin);
    var g2 = v2 > 0 ? N("fixed-size") : "";
    return import_react.default.createElement("div", p({}, a2, { className: m(N("slide"), null != this.context.trayPadding && this.context.visibleSlides % 2 == 1 && N("align-center"), n), style: y2 }), import_react.default.createElement("div", p({}, s, { className: m(N("slide-inner-margin")), style: b3 }), import_react.default.createElement("div", p({}, o, { className: m(N("slide-inner-padding")), style: x2 }), import_react.default.createElement("div", p({}, l, { className: m(N("slide-inner-wrapper"), g2, null == l ? void 0 : l.className) }), i2))));
  }, i;
}(import_react.Component);
I.contextType = v;
var L = function(e2) {
  function i() {
    var t2 = null !== e2 && e2.apply(this, arguments) || this;
    return t2.className = "slider-button", t2.ariaLabel = "", t2.isBack = true, t2.onClick = function() {
    }, t2;
  }
  return d(i, e2), i.prototype.handleOnClick = function(t2) {
    var e3 = this.context.currentSlide, i2 = this.context.step, r = this.context.totalSlides - this.context.visibleSlides, n = e3 + (t2 ? i2 : -1 * i2);
    n > r ? n = r : n < 0 && (n = 0), e3 !== n && this.context.slideTo(n);
  }, i.prototype.render = function() {
    var e3 = this, i2 = this.context, r = i2.visibleSlides, n = i2.totalSlides, s = i2.currentSlide, o = this.props, l = o.className, a2 = o.disabled, c3 = o.onClick, d2 = u(o, ["className", "disabled", "onClick"]), h2 = m(this.className, l), f2 = n - r;
    return null == a2 && (this.isBack && s <= 0 || !this.isBack && s >= f2) && (a2 = true), import_react.default.createElement("button", p({ "aria-label": this.ariaLabel, type: "button", disabled: a2 }, d2, { className: h2, onClick: function(t2) {
      c3 && "function" == typeof c3 && c3(t2), e3.onClick();
    } }), this.props.children);
  }, i;
}(import_react.default.PureComponent);
L.contextType = v;
var _ = function(t2) {
  function e2(e3) {
    var i = t2.call(this, e3) || this;
    return i.className = m(N("slider-button-back"), N(i.className)), i.ariaLabel = "previous", i.onClick = function() {
      return i.handleOnClick(false);
    }, i;
  }
  return d(e2, t2), e2;
}(L);
var G = function(t2) {
  function e2(e3) {
    var i = t2.call(this, e3) || this;
    return i.isBack = false, i.className = m(N("slider-button-next"), N(i.className)), i.ariaLabel = "next", i.onClick = function() {
      return i.handleOnClick(true);
    }, i;
  }
  return d(e2, t2), e2;
}(L);
var B = function(t2) {
  function e2(e3) {
    var i = t2.call(this, e3) || this;
    return i.slideTo = function(t3) {
      var e4 = i.context.currentSlide, r = i.context.totalSlides - i.context.visibleSlides;
      t3 > r ? t3 = r : t3 < 0 && (t3 = 0), e4 !== t3 && i.context.slideTo(t3);
    }, i.onScroll = function(t3, e4, r) {
      var n = r / (i.context.totalSlides * e4) * 100;
      i.setState({ left: n });
    }, i.state = { left: 0 }, i;
  }
  return d(e2, t2), e2.prototype.componentDidUpdate = function(t3, e3, i) {
    this.prevContext.subscribers !== this.context.subscribers && (this.context.subscribers.push(this.onScroll), this.prevContext = this.context);
  }, e2.prototype.componentDidMount = function() {
    var t3 = this.context, e3 = t3.currentSlide;
    t3.visibleSlides;
    var i = t3.totalSlides;
    if (this.context.subscribers.push(this.onScroll), this.prevContext = this.context, 0 !== e3) {
      var r = e3 / i * 100;
      this.setState({ left: r });
    }
  }, e2.prototype.componentWillUnmount = function() {
    var t3 = this.context.subscribers.indexOf(this.onScroll);
    t3 >= 0 && this.context.subscribers.splice(t3, 1);
  }, e2;
}(import_react.Component);
B.contextType = v;
var w = function(e2) {
  function i() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return d(i, e2), i.prototype.render = function() {
    var e3 = this.context, i2 = e3.visibleSlides, r = e3.totalSlides, n = this.props, s = n.className, o = n.style, l = n.thumbProps, a2 = n.trackProps, c3 = u(n, ["className", "style", "thumbProps", "trackProps"]), d2 = i2 / r * 100, h2 = this.state.left;
    h2 < 0 && (d2 += h2, h2 = 0), h2 + d2 > 100 && (d2 = 100 - h2);
    var f2 = { width: d2 + "%", left: h2 + "%" }, v2 = m(N("slider-bar"), s);
    return l && (f2 = p(p({}, l.style), f2)), import_react.default.createElement("div", p({}, c3, { className: v2, style: o }), import_react.default.createElement("div", p({}, a2, { className: m(N("slider-bar-track"), null == a2 ? void 0 : a2.className) }), import_react.default.createElement("div", p({}, l, { className: m(N("slider-bar-thumb"), null == l ? void 0 : l.className), style: f2 }))));
  }, i;
}(B);
var U = function(e2) {
  function i() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return d(i, e2), i.prototype.theDot = function(e3, i2, r) {
    return import_react.default.createElement("div", { className: m(N("slider-dot-wrapper"), i2 ? N("active") : ""), onClick: r }, import_react.default.createElement("div", { key: e3, className: m(N("slider-dot")) }));
  }, i.prototype.renderDots = function(t2) {
    for (var e3 = t2.visibleSlides, i2 = t2.totalSlides, r = t2.currentSlide, n = t2.slideTo, s = [], o = r, l = r + e3, a2 = function(t3) {
      var e4 = o <= t3 && t3 < l;
      s.push(c3.theDot(t3, e4, function() {
        return n(t3);
      }));
    }, c3 = this, d2 = 0; d2 < i2; ++d2) a2(d2);
    return s;
  }, i.prototype.render = function() {
    var e3 = this.context, i2 = e3.visibleSlides, r = e3.totalSlides, n = e3.step, s = e3.currentSlide, o = this.props;
    o.children;
    var l = o.className, a2 = o.dotGroupProps, c3 = o.renderDots, d2 = u(o, ["children", "className", "dotGroupProps", "renderDots"]), h2 = { visibleSlides: i2, totalSlides: r, step: n, currentSlide: s, left: this.state.left, slideTo: this.slideTo }, f2 = m(N("slider-bar"), l);
    return import_react.default.createElement("div", p({}, d2, { className: f2 }), import_react.default.createElement("div", p({}, a2, { className: m(N("slider-bar-dot-group"), null == a2 ? void 0 : a2.className) }), c3 ? c3(h2) : this.renderDots(h2)));
  }, i;
}(B);
function W(e2, i) {
  var r = e2.visibleSlides, n = e2.totalSlides;
  e2.step;
  for (var s = e2.left, o = e2.currentSlide, l = e2.slideTo, a2 = [], c3 = b2(r / n), d2 = b2(s / 100), p2 = d2 + c3, u2 = b2(1 / n), h2 = o, f2 = o + r, v2 = function(e3) {
    var r2 = b2(e3 / n), s2 = b2(r2 + u2), o2 = 1, c4 = h2 <= e3 && e3 < f2;
    if (r2 < p2 && s2 > d2) {
      if (r2 <= d2 && d2 <= s2) o2 += (s2 - d2) / u2;
      else if (d2 <= r2 && s2 <= p2) o2 = 2;
      else if (r2 <= p2 && p2 <= s2) {
        o2 += (p2 - r2) / u2;
      }
    }
    a2.push(import_react.default.createElement(i, { key: e3, scale: o2, active: c4, onClick: function() {
      l(e3);
    } }));
  }, y2 = 0; y2 < n; ++y2) v2(y2);
  return a2;
}
function A(e2) {
  return import_react.default.createElement("div", { className: m(N("slider-dot-wrapper"), N("dynamic"), e2.active ? N("active") : ""), onClick: e2.onClick }, import_react.default.createElement("div", { className: m(N("slider-dot"), N("circle")), style: { transform: "scale(".concat(e2.scale, ")") } }));
}
function F(t2) {
  return W(t2, A);
}
function T(e2) {
  return import_react.default.createElement("div", { className: m(N("slider-dot-wrapper"), N("dynamic"), e2.active ? N("active") : ""), onClick: e2.onClick }, import_react.default.createElement("div", { className: m(N("slider-dot"), N("circle")), style: { width: "".concat(8 * e2.scale, "px"), height: "".concat(8, "px") } }));
}
function Z(t2) {
  return W(t2, T);
}
export {
  _ as ButtonBack,
  G as ButtonNext,
  C as Carousel,
  A as CircleDot,
  T as PillDot,
  I as Slide,
  Q as Slider,
  U as SliderBarDotGroup,
  w as SliderBarLine,
  y as add,
  m as cn,
  x as deepCompare,
  W as renderDotsDynamicByScale,
  F as renderDotsDynamicCircle,
  Z as renderDotsDynamicPill,
  b2 as round3
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@popmotion/popcorn/dist/popcorn.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=react-scroll-snap-anime-slider.js.map
